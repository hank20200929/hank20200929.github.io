<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式的七大原则及创建型模式</title>
      <link href="2021/11/24/design-pattern-01/"/>
      <url>2021/11/24/design-pattern-01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h4><h5 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h5><p>对扩展开放，对修改关闭</p><p><strong>【例1】Windows 的桌面主题设计</strong><br>分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如图 1 所示。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124111250623.png" alt="image-20211124111250623" loading="lazy"></p><h5 id="里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle，LSP）"></a>里氏替换原则（Liskov Substitution Principle，LSP）</h5><p>子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。总结如下：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li></ul><p>关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。</p><h5 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h5><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：<strong>要面向接口编程，不要面向实现编程。</strong>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><p>我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><p><strong>【例1】依赖倒置原则在“顾客购物程序”中的应用。</strong></p><p>分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(ShaoguanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(WuyuanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif" alt="顾客购物程序的类图" loading="lazy"></p><h5 id="单一职责原则（Single-Responsibility-Principle，SRP）"><a href="#单一职责原则（Single-Responsibility-Principle，SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle，SRP）"></a>单一职责原则（Single Responsibility Principle，SRP）</h5><p>这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。</p><p><strong>【例1】大学学生工作管理程序。</strong></p><p>分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图 1 所示。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124114625666.png" alt="image-20211124114625666" loading="lazy"></p><p><strong>注意：</strong>单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><h5 id="接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle，ISP）"></a>接口隔离原则（Interface Segregation Principle，ISP）</h5><p>要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p><strong>【例1】学生成绩管理程序。</strong></p><p>分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124115259010.png" alt="image-20211124115259010" loading="lazy"></p><h5 id="最少知识原则（Least-Knowledge-Principle，LKP"><a href="#最少知识原则（Least-Knowledge-Principle，LKP" class="headerlink" title="最少知识原则（Least Knowledge Principle，LKP)"></a>最少知识原则（Least Knowledge Principle，LKP)</h5><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。（只与你的直接朋友交谈，不跟“陌生人”说话）</p><p><strong>但是，</strong>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><ol><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ol><p><strong>【例1】明星与经纪人的关系实例。</strong></p><p>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 1 所示。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124120001164.png" alt="image-20211124120001164" loading="lazy"></p><h5 id="合成复用原则（Composite-Reuse-Principle，CRP）"><a href="#合成复用原则（Composite-Reuse-Principle，CRP）" class="headerlink" title="合成复用原则（Composite Reuse Principle，CRP）"></a>合成复用原则（Composite Reuse Principle，CRP）</h5><p>要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。</p><p><strong>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</strong></p><p><strong>【例1】汽车分类管理程序。</strong></p><p>分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继承关系实现的汽车分类的类图。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124134448019.png" alt="image-20211124134448019" loading="lazy"></p><p>从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124134553854.png" alt="image-20211124134553854" loading="lazy"></p><table><thead><tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr><tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr><tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr><tr><td>最少知识原则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr><tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr></tbody></table><p>实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p><blockquote><p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p></blockquote><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p><p>创建型模式分为以下几种。</p><ul><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ul><p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。单例模式有 3 个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><h6 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h6><p>通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><p>单例模式的主要角色如下。</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><img src="/2021/11/24/design-pattern-01/image-20211124135536295.png" alt="image-20211124135536295" style="zoom: 67%;" loading="lazy"><h6 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h6><ul><li><p>懒汉式</p><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p><ul><li><p>饿汉式</p><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，其结构图如图 5 所示。</p><img src="/2021/11/24/design-pattern-01/image-20211124141326623.png" alt="image-20211124141326623" style="zoom:67%;" loading="lazy"><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。</p><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。</p><h6 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h6><p>原型模式包含以下主要角色。</p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol><img src="/2021/11/24/design-pattern-01/image-20211124141549657.png" alt="image-20211124141549657" style="zoom:80%;" loading="lazy"><h6 id="原型模式的实现"><a href="#原型模式的实现" class="headerlink" title="原型模式的实现"></a>原型模式的实现</h6><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java 中的 Object 类提供了浅克隆的 clone() 方法，<strong>具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype obj1 = <span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2 = (Realizetype) obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span> + (obj1 == obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图如图 5 所示。</p><p><img src="/2021/11/24/design-pattern-01/image-20211124144647917.png" alt="image-20211124144647917" loading="lazy"></p><p>【例3】用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，图 6 所示是其结构图。<img src="/2021/11/24/design-pattern-01/image-20211124144624523.png" alt="image-20211124144624523" loading="lazy"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iflyteker.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>;    <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countArea</span><span class="params">()</span></span>;    <span class="comment">//计算面积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Circle w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = (Circle) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝圆失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;这是一个圆，请输入圆的半径：&quot;</span>);</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        r = input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;该圆的面积=&quot;</span> + <span class="number">3.1415</span> * r * r + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Square b = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b = (Square) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝正方形失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;这是一个正方形，请输入它的边长：&quot;</span>);</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        a = input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;该正方形的面积=&quot;</span> + a * a + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Shape&gt; ht = <span class="keyword">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ht.put(<span class="string">&quot;Circle&quot;</span>, <span class="keyword">new</span> Circle());</span><br><span class="line">        ht.put(<span class="string">&quot;Square&quot;</span>, <span class="keyword">new</span> Square());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addshape</span><span class="params">(String key, Shape obj)</span> </span>&#123;</span><br><span class="line">        ht.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Shape temp = ht.get(key);</span><br><span class="line">        <span class="keyword">return</span> (Shape) temp.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProtoTypeManager pm = <span class="keyword">new</span> ProtoTypeManager();</span><br><span class="line">        Shape obj1 = (Circle) pm.getShape(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">        obj1.countArea();</span><br><span class="line">        Shape obj2 = (Shape) pm.getShape(<span class="string">&quot;Square&quot;</span>);</span><br><span class="line">        obj2.countArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。</p><p>工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，<strong>只要一个工厂类</strong>就可以完成，这种模式叫“<strong>简单工厂模式</strong>”。在简单工厂模式中创建实例的方法通常为静态（static）方法，因此又叫作静态工厂方法模式（Static Factory Method Pattern）。</p><p>简单工厂模式不在 GoF 23 种设计模式之列。（简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。）</p><h6 id="简单工厂模式的结构"><a href="#简单工厂模式的结构" class="headerlink" title="简单工厂模式的结构"></a>简单工厂模式的结构</h6><p>简单工厂模式的主要角色如下：</p><ul><li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li><li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li></ul><p><img src="/2021/11/24/design-pattern-01/image-20211124151126048.png" alt="image-20211124151126048" loading="lazy"></p><h6 id="简单工厂模式的实现"><a href="#简单工厂模式的实现" class="headerlink" title="简单工厂模式的实现"></a>简单工厂模式的实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iflyteker.dp.easyFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.bind.v2.runtime.reflect.opt.Const;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: testJava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Hank</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-24 15:33</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = SimpleFactory.makeProduct(<span class="number">1</span>);</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><h6 id="工厂方法模式的结构"><a href="#工厂方法模式的结构" class="headerlink" title="工厂方法模式的结构"></a>工厂方法模式的结构</h6><p>工厂方法模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><p><img src="/2021/11/24/design-pattern-01/image-20211124160154741.png" alt="image-20211124160154741" loading="lazy"></p><h6 id="工厂方法模式的实现"><a href="#工厂方法模式的实现" class="headerlink" title="工厂方法模式的实现"></a>工厂方法模式的实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iflyteker.dp.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Product a;</span><br><span class="line">        AbstractFactory af = (AbstractFactory) Class.forName(<span class="string">&quot;iflyteker.dp.factory.ConcreteFactory1&quot;</span>).newInstance();</span><br><span class="line">        a = af.newProduct();</span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂：提供了产品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂1：实现了产品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂2：实现了产品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>工厂方法模式只考虑生产同种类（等级）的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多种类（等级）的产品。</p><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h6 id="抽象工厂模式的结构"><a href="#抽象工厂模式的结构" class="headerlink" title="抽象工厂模式的结构"></a>抽象工厂模式的结构</h6><p>抽象工厂模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ol><p><img src="/2021/11/24/design-pattern-01/image-20211124162433676.png" alt="image-20211124162433676" loading="lazy"></p><h6 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h6><p>从图 2 可以看出抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。下面给出抽象工厂和具体工厂的代码。</p><p>(1) 抽象工厂：提供了产品的生成方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">newProduct1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">newProduct2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 具体工厂：实现了产品的生成方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">newProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct11();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">newProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct21();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p><ol><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li></ol><p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p><h6 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h6><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><h6 id="建造者模式的结构"><a href="#建造者模式的结构" class="headerlink" title="建造者模式的结构"></a>建造者模式的结构</h6><p>建造者（Builder）模式的主要角色如下。</p><ol><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><img src="/2021/11/24/design-pattern-01/image-20211124163935282.png" alt="image-20211124163935282" style="zoom:80%;" loading="lazy"><h6 id="建造者模式的实现"><a href="#建造者模式的实现" class="headerlink" title="建造者模式的实现"></a>建造者模式的实现</h6><p>(1) 产品角色：包含多个组成部件的复杂对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 具体建造者：实现了抽象建造者接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) 客户类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【例1】用建造者（Builder）模式描述客厅装修。</strong></p><p>分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。</p><p>这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。</p><img src="/2021/11/24/design-pattern-01/image-20211124164945155.png" alt="image-20211124164945155" style="zoom:67%;" loading="lazy"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iflyteker.dp.builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParlourDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Decorator d = (Decorator) Class.forName(<span class="string">&quot;iflyteker.dp.builder.ConcreteDecorator2&quot;</span>).newInstance();</span><br><span class="line">            ProjectManager m = <span class="keyword">new</span> ProjectManager(d);</span><br><span class="line">            Parlour p = m.decorate();</span><br><span class="line">            p.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品：客厅</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parlour</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String wall;    <span class="comment">//墙</span></span><br><span class="line">    <span class="keyword">private</span> String TV;    <span class="comment">//电视</span></span><br><span class="line">    <span class="keyword">private</span> String sofa;    <span class="comment">//沙发</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTV</span><span class="params">(String TV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.TV = TV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSofa</span><span class="params">(String sofa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sofa = sofa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.wall);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.TV);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.sofa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象建造者：装修工人</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Parlour product = <span class="keyword">new</span> Parlour();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTV</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSofa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parlour <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体建造者：具体装修工人1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setWall(<span class="string">&quot;w1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setTV(<span class="string">&quot;TV1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSofa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setSofa(<span class="string">&quot;sf1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体建造者：具体装修工人2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator2</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setWall(<span class="string">&quot;w2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setTV(<span class="string">&quot;TV2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSofa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setSofa(<span class="string">&quot;sf2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者：项目经理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Decorator builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProjectManager</span><span class="params">(Decorator builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parlour <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildWall();</span><br><span class="line">        builder.buildTV();</span><br><span class="line">        builder.buildSofa();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h6><p>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="2021/11/24/java-reflaction/"/>
      <url>2021/11/24/java-reflaction/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="反射机制概述"><a href="#反射机制概述" class="headerlink" title="反射机制概述"></a>反射机制概述</h4><p>反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p><img src="/2021/11/24/java-reflaction/image-20211124100840289.png" alt="image-20211124100840289" loading="lazy"></p><h5 id="Java反射机制提供的功能："><a href="#Java反射机制提供的功能：" class="headerlink" title="Java反射机制提供的功能："></a>Java反射机制提供的功能：</h5><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h5 id="反射相关的主要API："><a href="#反射相关的主要API：" class="headerlink" title="反射相关的主要API："></a>反射相关的主要API：</h5><ul><li>java.lang.Class:代表一个类</li><li>java.lang.reflect.Method:代表类的方法</li><li>java.lang.reflect.Field:代表类的成员变量</li><li>java.lang.reflect.Constructor:代表类的构造器</li></ul><h4 id="Class类并获取Class实例"><a href="#Class类并获取Class实例" class="headerlink" title="Class类并获取Class实例"></a>Class类并获取Class实例</h4><h5 id="Class类的常用方法："><a href="#Class类的常用方法：" class="headerlink" title="Class类的常用方法："></a>Class类的常用方法：</h5><ul><li>static Class  forName(String name)：返回指定类名  name 的  Class 对象</li><li>Object newInstance() ：调用缺省构造函数，返回该Class对象的一个实例</li><li>getName()：返回此Class对象所表示的实体（类、接口、数组类、基本类型 或void）名称</li><li>Class getSuperClass()：返回当前Class对象的父类的Class对象</li><li>Class [] getInterfaces() ：获取当前Class对象的接口</li><li>ClassLoader getClassLoader()： 返回该类的类加载器</li><li>Class getSuperclass()：返回表示此Class所表示的实体的超类的Class</li><li>Constructor[] getConstructors()：返回一个包含某些Constructor对象的数组</li><li>Field[] getDeclaredFields()：返回Field对象的一个数组</li><li>Method getMethod(String name,Class … paramTypes)：返回一个Method对象，此对象的形参类型为paramType</li></ul><h5 id="获取Class类的实例-四种方法-："><a href="#获取Class类的实例-四种方法-：" class="headerlink" title="获取Class类的实例(四种方法)："></a>获取Class类的实例(四种方法)：</h5><ul><li>若已知具体的类，通过类的class属性获取，该方法最为安全可靠， 程序性能最高</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = String.class;</span><br></pre></td></tr></table></figure><ul><li>已知某个类的实例，调用该实例的getClass()方法获取Class对象 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = “www.atguigu.com”.getClass();</span><br></pre></td></tr></table></figure><ul><li>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(“java.lang.String”);</span><br></pre></td></tr></table></figure><ul><li>其他方式(不做要求)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader(); </span><br><span class="line">Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure><h5 id="哪些类型可以有Class对象？"><a href="#哪些类型可以有Class对象？" class="headerlink" title="哪些类型可以有Class对象？"></a>哪些类型可以有Class对象？</h5><ul><li>（1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li><li>（2）interface：接口</li><li>（3）[]：数组</li><li>（4）enum：枚举</li><li>（5）annotation：注解@interface</li><li>（6）primitive type：基本数据类型</li><li>（7）void</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Object.class;</span><br><span class="line">Class c2 = Comparable.class;</span><br><span class="line">Class c3 = String[].class;</span><br><span class="line">Class c4 = <span class="keyword">int</span>[][].class;</span><br><span class="line">Class c5 = ElementType.class;</span><br><span class="line">Class c6 = Override.class;</span><br><span class="line">Class c7 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">Class c9 = Class.class;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]; Class c10 = a.getClass(); Class c11 = b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11);</span></span><br></pre></td></tr></table></figure><h4 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h4><p>通过调用Class对象的newInstance()方法创建运行时类的对象</p><p><strong>要求：</strong>        </p><ul><li>1）类必须有一个无参数的构造器。</li><li>2）类的构造器的访问权限需要足够</li></ul><p>当没有无参的构造器时，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</p><ul><li>1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li><li>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>3）通过Constructor实例化对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根据全类名获取对应的Class对象</span></span><br><span class="line">String name = “atguigu.java.Person<span class="string">&quot;; Class clazz = null;</span></span><br><span class="line"><span class="string">clazz = Class.forName(name);</span></span><br><span class="line"><span class="string">//2.调用指定参数结构的构造器，生成Constructor的实例</span></span><br><span class="line"><span class="string">Constructor con = clazz.getConstructor(String.class,Integer.class);</span></span><br><span class="line"><span class="string">//3.通过Constructor的实例创建对应类的对象，并初始化类属性</span></span><br><span class="line"><span class="string">Person p2 = (Person) con.newInstance(&quot;</span>Peter<span class="string">&quot;,20); System.out.println(p2);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉链表技术及实现原理</title>
      <link href="2021/08/05/dw-zipping-table/"/>
      <url>2021/08/05/dw-zipping-table/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="什么是拉链表"><a href="#什么是拉链表" class="headerlink" title="什么是拉链表"></a>什么是拉链表</h4><blockquote><p>所谓拉链，就是记录历史。记录一个事物从开始，一直到当前状态的所有变化的信息。</p></blockquote><a id="more"></a><p>先看一个示例，存储的是用户的最基本信息以及每条记录的生命周期。</p><table><thead><tr><th>注册日期</th><th>用户编号</th><th>手机号码</th><th>t_start_date</th><th>t_end_date</th></tr></thead><tbody><tr><td>2017/1/1</td><td>1</td><td>111111</td><td>2017/1/1</td><td>9999/12/31</td></tr><tr><td>2017/1/1</td><td>2</td><td>222222</td><td>2017/1/1</td><td>2017/1/1</td></tr><tr><td>2017/1/1</td><td>2</td><td>233333</td><td>2017/1/2</td><td>9999/12/31</td></tr><tr><td>2017/1/1</td><td>3</td><td>333333</td><td>2017/1/1</td><td>9999/12/31</td></tr><tr><td>2017/1/1</td><td>4</td><td>444444</td><td>2017/1/1</td><td>2017/1/1</td></tr><tr><td>2017/1/1</td><td>4</td><td>432432</td><td>2017/1/2</td><td>2017/1/2</td></tr><tr><td>2017/1/1</td><td>4</td><td>432432</td><td>2017/1/3</td><td>9999/12/31</td></tr><tr><td>2017/1/2</td><td>5</td><td>555555</td><td>2017/1/2</td><td>2017/1/2</td></tr><tr><td>2017/1/2</td><td>5</td><td>115115</td><td>2017/1/3</td><td>9999/12/31</td></tr><tr><td>2017/1/3</td><td>6</td><td>666666</td><td>2017/1/3</td><td>9999/12/31</td></tr></tbody></table><h4 id="拉链表的使用场景"><a href="#拉链表的使用场景" class="headerlink" title="拉链表的使用场景"></a>拉链表的使用场景</h4><p>在数据仓库的数据模型设计过程中，经常会遇到下面这种表的设计：</p><ul><li>有一些表的<strong>数据量很大</strong>，比如一张用户表，大约10亿条记录，50个字段，这种表，即使使用ORC压缩，单张表的存储也会超过100G，在HDFS使用双备份或者三备份的话就更大一些。</li><li>表中的<strong>部分字段会被update更新操作</strong>，如用户联系方式，产品的描述信息，订单的状态等等。<br>需要查看某一个时间点或者时间段的历史快照信息，比如，查看某一个订单在历史某一个时间点的状态。</li><li>表中的<strong>记录变化的比例和频率不是很大</strong>，比如，总共有10亿的用户，每天新增和发生变化的有200万左右，变化的比例占的很小。</li></ul><p>那么对于这种表我该如何设计呢？下面有几种方案可选：</p><ul><li>方案一：每天只留最新的一份，比如我们每天用抽取最新的一份全量数据到Hive中。</li><li>方案二：每天保留一份全量的切片数据。</li><li>方案三：使用拉链表。</li></ul><h4 id="为什么使用拉链表"><a href="#为什么使用拉链表" class="headerlink" title="为什么使用拉链表"></a>为什么使用拉链表</h4><ul><li><strong>方案一</strong></li></ul><p>这种方案就不用多说了，实现起来很简单，每天drop掉前一天的数据，重新抽一份最新的。</p><p>优点很明显，节省空间，一些普通的使用也很方便，不用在选择表的时候加一个时间分区什么的。</p><p>缺点同样明显，<strong>没有历史数据</strong>，先翻翻旧账只能通过其它方式，比如从流水表里面抽。</p><ul><li><strong>方案二</strong></li></ul><p>每天一份全量的切片是一种比较稳妥的方案，而且历史数据也在。</p><p>缺点就是存储空间<strong>占用量太大太大了</strong>，如果对这边表每天都保留一份全量，那么每次全量中会保存很多不变的信息，对存储是极大的浪费，这点我感触还是很深的…</p><p>当然我们也可以做一些取舍，比如只保留近一个月的数据？但是，需求是无耻的，数据的生命周期不是我们能完全左右的。</p><ul><li><strong>拉链表</strong></li></ul><p>拉链表在使用上基本兼顾了我们的需求。</p><p>首先它在空间上做了一个取舍，虽说不像方案一那样占用量那么小，但是它每日的增量可能只有方案二的千分之一甚至是万分之一。</p><p>其实它能满足方案二所能满足的需求，既能获取最新的数据，也能添加筛选条件也获取历史的数据。</p><p>所以我们还是很有必要来使用拉链表的。</p><h4 id="拉链表的设计和实现"><a href="#拉链表的设计和实现" class="headerlink" title="拉链表的设计和实现"></a>拉链表的设计和实现</h4><p>先看一下在Mysql里user表中信息变化。</p><ul><li>2021-01-01中的数据为</li></ul><table><thead><tr><th>注册日期</th><th>用户编号</th><th>手机号码</th></tr></thead><tbody><tr><td>2017-01-01</td><td>001</td><td>111111</td></tr><tr><td>2017-01-01</td><td>002</td><td>222222</td></tr><tr><td>2017-01-01</td><td>003</td><td>333333</td></tr><tr><td>2017-01-01</td><td>004</td><td>444444</td></tr></tbody></table><ul><li>2021-01-02中的数据为</li></ul><table><thead><tr><th>注册日期</th><th>用户编号</th><th>手机号码</th><th>备注</th></tr></thead><tbody><tr><td>2017/1/1</td><td>001</td><td>111111</td><td></td></tr><tr><td>2017/1/1</td><td>002</td><td>233333</td><td>（由222222变成233333）</td></tr><tr><td>2017/1/1</td><td>003</td><td>333333</td><td></td></tr><tr><td>2017/1/1</td><td>004</td><td>432432</td><td>（由444444变成432432）</td></tr><tr><td>2017/1/2</td><td>005</td><td>555555</td><td>（2017-01-02新增）</td></tr></tbody></table><ul><li>2021-01-03中的数据为</li></ul><table><thead><tr><th>注册日期</th><th>用户编号</th><th>手机号码</th><th>备注</th></tr></thead><tbody><tr><td>2017/1/1</td><td>001</td><td>111111</td><td></td></tr><tr><td>2017/1/1</td><td>002</td><td>233333</td><td></td></tr><tr><td>2017/1/1</td><td>003</td><td>333333</td><td></td></tr><tr><td>2017/1/1</td><td>004</td><td>654321</td><td>（由432432变成654321）</td></tr><tr><td>2017/1/2</td><td>005</td><td>115115</td><td>（由555555变成115115）</td></tr><tr><td>2017/1/3</td><td>006</td><td>666666</td><td>（2017-01-03新增）</td></tr></tbody></table><p>如果在数据仓库中设计成历史拉链表保存该表，则会有下面这样一张表，这是最新一天（即2021-01-03）的数据：</p><table><thead><tr><th>注册日期</th><th>用户编号</th><th>手机号码</th><th>t_start_date</th><th>t_end_date</th></tr></thead><tbody><tr><td>2017/1/1</td><td>001</td><td>111111</td><td>2017/1/1</td><td>9999/12/31</td></tr><tr><td>2017/1/1</td><td>002</td><td>222222</td><td>2017/1/1</td><td>2017/1/1</td></tr><tr><td>2017/1/1</td><td>002</td><td>233333</td><td>2017/1/2</td><td>9999/12/31</td></tr><tr><td>2017/1/1</td><td>003</td><td>333333</td><td>2017/1/1</td><td>9999/12/31</td></tr><tr><td>2017/1/1</td><td>004</td><td>444444</td><td>2017/1/1</td><td>2017/1/1</td></tr><tr><td>2017/1/1</td><td>004</td><td>432432</td><td>2017/1/2</td><td>2017/1/2</td></tr><tr><td>2017/1/1</td><td>004</td><td>654321</td><td>2017/1/3</td><td>9999/12/31</td></tr><tr><td>2017/1/2</td><td>005</td><td>555555</td><td>2017/1/2</td><td>2017/1/2</td></tr><tr><td>2017/1/2</td><td>005</td><td>115115</td><td>2017/1/3</td><td>9999/12/31</td></tr><tr><td>2017/1/3</td><td>006</td><td>666666</td><td>2017/1/3</td><td>9999/12/31</td></tr></tbody></table><p><strong>说明</strong></p><ul><li>t_start_date表示该条记录的生命周期开始时间，t_end_date表示该条记录的生命周期结束时间。</li><li>t_end_date = ‘9999-12-31’表示该条记录目前处于有效状态。</li><li>如果查询当前所有有效的记录，则select * from user where t_end_date = ‘9999-12-31’。</li><li>如果查询2021-01-02的历史快照，则select * from user where t_start_date &lt;= ‘2021-01-02’ and t_end_date &gt;= ‘2021-01-02’。</li></ul><h4 id="在Hive中实现拉链表"><a href="#在Hive中实现拉链表" class="headerlink" title="在Hive中实现拉链表"></a>在Hive中实现拉链表</h4><blockquote><p>首先我们需要先确定一下我们有哪些数据源可以用</p></blockquote><ul><li><p>我们需要一张ODS层的用户全量表。至少需要用它来初始化。</p></li><li><p>每日的用户更新表。</p></li></ul><blockquote><p>然后，我们要确定拉链表的时间粒度</p></blockquote><p>比如说拉链表每天只取一个状态，也就是说如果一天有3个状态变更，我们只取最后一个状态，这种天粒度的表其实已经能解决大部分的问题了。</p><p>另外，补充一下每日的用户更新表该怎么获取，据笔者的经验，有3种方式拿到或者间接拿到每日的用户增量，因为它比较重要，所以详细说明：</p><ul><li>我们可以监听Mysql数据的变化，比如说用Canal，最后合并每日的变化，获取到最后的一个状态。</li><li>假设我们每天都会获得一份切片数据，我们可以通过取两天切片数据的不同来作为每日更新表，这种情况下我们可以对所有的字段先进行concat，再取md5，这样就ok了。</li><li>流水表！有每日的变更流水表。</li></ul><blockquote><p>拉链表的实现</p></blockquote><ul><li><strong>ods层的user表</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ods.user (</span><br><span class="line">  user_num <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  mobile <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;手机号码&#x27;</span>,</span><br><span class="line">  reg_date <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;注册日期&#x27;</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">&#x27;用户资料表&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> ORC</span><br><span class="line">LOCATION <span class="string">&#x27;/ods/user&#x27;</span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong>ods层的user_update表</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ods.user_update (</span><br><span class="line">  user_num <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  mobile <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;手机号码&#x27;</span>,</span><br><span class="line">  reg_date <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;注册日期&#x27;</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">&#x27;每日用户资料更新表&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> ORC</span><br><span class="line">LOCATION <span class="string">&#x27;/ods/user_update&#x27;</span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong>拉链表</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> dws.user_his (</span><br><span class="line">  user_num <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  mobile <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;手机号码&#x27;</span>,</span><br><span class="line">  reg_date <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  t_start_date ,</span><br><span class="line">  t_end_date</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">&#x27;用户资料拉链表&#x27;</span></span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> ORC</span><br><span class="line">LOCATION <span class="string">&#x27;/dws/user_his&#x27;</span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong>实现sql语句</strong></li></ul><p>现在我们假设我们已经已经初始化了2021-01-01的日期，然后需要更新2021-01-02那一天的数据，我们有了下面的sql。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line">  OVERWRITE <span class="keyword">TABLE</span> dws.user_his</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      A.user_num,</span><br><span class="line">      A.mobile,</span><br><span class="line">      A.reg_date,</span><br><span class="line">      A.t_start_date,</span><br><span class="line">      <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> A.t_end_date = <span class="string">&#x27;99991231&#x27;</span>   <span class="comment">-- 请勿遗漏这个条件</span></span><br><span class="line">        <span class="keyword">AND</span> B.user_num <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;20210101&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> A.t_end_date</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">AS</span> t_end_date</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      dws.user_his <span class="keyword">AS</span> A</span><br><span class="line">      <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ods.user_update <span class="keyword">AS</span> B <span class="keyword">ON</span> A.user_num = B.user_num</span><br><span class="line">    <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      C.user_num,</span><br><span class="line">      C.mobile,</span><br><span class="line">      C.reg_date,</span><br><span class="line">      <span class="string">&#x27;20210102&#x27;</span> <span class="keyword">AS</span> t_start_date,<span class="comment">-- 开始时间应该为2号当天</span></span><br><span class="line">      <span class="string">&#x27;99991231&#x27;</span> <span class="keyword">AS</span> t_end_date</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      ods.user_update <span class="keyword">AS</span> C</span><br><span class="line">  ) <span class="keyword">AS</span> T</span><br></pre></td></tr></table></figure><blockquote><p>示例</p></blockquote><p><strong>20210101的数据</strong></p><table><thead><tr><th>user_num</th><th>mobile</th><th>reg_date</th></tr></thead><tbody><tr><td>1</td><td>11111111111</td><td>20210101</td></tr><tr><td>2</td><td>22222222222</td><td>20210101</td></tr><tr><td>3</td><td>33333333333</td><td>20210101</td></tr><tr><td>4</td><td>44444444444</td><td>20210101</td></tr></tbody></table><p><strong>20210102的更新数据</strong></p><table><thead><tr><th>user_num</th><th>mobile</th><th>reg_date</th></tr></thead><tbody><tr><td>5</td><td>55555555555</td><td>20210101</td></tr><tr><td>2</td><td>22222222211</td><td>20210101</td></tr></tbody></table><p><strong>拉链表结果</strong></p><table><thead><tr><th>user_num</th><th>mobile</th><th>reg_date</th><th>t_start_date</th><th>t_end_date</th></tr></thead><tbody><tr><td>1</td><td>11111111111</td><td>20210101</td><td>20210101</td><td>99991231</td></tr><tr><td>2</td><td>22222222211</td><td>20210101</td><td>20170102</td><td>99991231</td></tr><tr><td>2</td><td>22222222222</td><td>20210101</td><td>20210101</td><td>20170101</td></tr><tr><td>3</td><td>33333333333</td><td>20210101</td><td>20210101</td><td>99991231</td></tr><tr><td>4</td><td>44444444444</td><td>20210101</td><td>20210101</td><td>99991231</td></tr><tr><td>5</td><td>55555555555</td><td>20210101</td><td>20170102</td><td>99991231</td></tr></tbody></table><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li><strong>拉链表和流水表</strong></li></ul><p>流水表存放的是一个用户的变更记录，比如在一张流水表中，一天的数据中，会存放一个用户的每条修改记录，但是在拉链表中只有一条记录。</p><p>这是拉链表设计时需要注意的一个<strong>粒度问题</strong>。我们当然也可以设置的粒度更小一些，<strong>一般按天就足够</strong>。</p><ul><li><strong>查询性能</strong></li></ul><p>比如说我们存放了5年的拉链数据，那么这张表势必会比较大，当查询的时候性能就比较低了，个人认为两个思路来解决：</p><ul><li>在一些查询引擎中，我们<strong>对start_date和end_date做索引</strong>，这样能提高不少性能。</li><li>保留部分历史数据，比如说我们<strong>一张表里面存放全量的拉链表数据，然后再对外暴露一张只提供近3个月数据的拉链表。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 维度表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维度建模总结</title>
      <link href="2021/08/05/dw-dimensional-modeling-04/"/>
      <url>2021/08/05/dw-dimensional-modeling-04/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="维度建模技术"><a href="#维度建模技术" class="headerlink" title="维度建模技术"></a>维度建模技术</h1><h2 id="基本概念及术语"><a href="#基本概念及术语" class="headerlink" title="基本概念及术语"></a>基本概念及术语</h2><h3 id="维度设计步骤"><a href="#维度设计步骤" class="headerlink" title="维度设计步骤"></a>维度设计步骤</h3><ul><li>选择业务过程</li><li>确定粒度</li><li>确定维度</li><li>确定事实</li></ul><h3 id="数据域"><a href="#数据域" class="headerlink" title="数据域"></a>数据域</h3><ul><li>指面向业务分析，将业务过程或维度进行抽象的集合。</li></ul><h3 id="业务过程"><a href="#业务过程" class="headerlink" title="业务过程"></a>业务过程</h3><ul><li><p>是一个不可拆分的行为事件，可以是如下内容</p><ul><li>单个业务事件：如支付、退款</li><li>某个事件的状态：如当前积分余额</li><li>一系列相关业务事件组成的业务流程</li></ul></li></ul><h3 id="度量-原子指标"><a href="#度量-原子指标" class="headerlink" title="度量/原子指标"></a>度量/原子指标</h3><ul><li>两者含义相同，基于某一业务事件行为下的度量，是业务定义中不可再拆分的指标，具有明确业务含义的名词，如支付金额</li></ul><h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3><ul><li>是维度的一个组合，用于确定某一事实表中的行表示什么。统计粒度通常作为派生指标的修饰词而存在</li></ul><h3 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h3><ul><li>维度是度量的环境，用来反映业务的一类属性，这类属性的集合构成一个维度。围绕某一业务过程事件所涉及的“谁、什么、何处、何时、为什么、如何”等背景。</li></ul><h3 id="维度属性"><a href="#维度属性" class="headerlink" title="维度属性"></a>维度属性</h3><ul><li>维度属性隶属于一个维度</li></ul><h3 id="退化维度"><a href="#退化维度" class="headerlink" title="退化维度"></a>退化维度</h3><ul><li>维度属性也可以存储到事实表中，这种存储到事实表中的维度列就被称为“退化维度”。退化维度也可以用来进行事实表的过滤查询、实现聚合操作等</li></ul><h3 id="事实"><a href="#事实" class="headerlink" title="事实"></a>事实</h3><ul><li>事实来自业务过程中的度量，一般都是以数值形式存在</li></ul><h3 id="代理键"><a href="#代理键" class="headerlink" title="代理键"></a>代理键</h3><ul><li>就是充当主键的字段本身不具有业务意义，只具有主键作用，比如自动增长的ID。代理键一般用于处理缓慢变化维。</li></ul><h3 id="自然键"><a href="#自然键" class="headerlink" title="自然键"></a>自然键</h3><ul><li>就是充当主键的字段本身具有一定的含义，是构成记录的组成部分，比如商品的条码，除了充当主键之外，同时也是商品记录的重要组成部分。</li></ul><h3 id="Kimball多维体系结构中的三个关键性概念"><a href="#Kimball多维体系结构中的三个关键性概念" class="headerlink" title="Kimball多维体系结构中的三个关键性概念"></a>Kimball多维体系结构中的三个关键性概念</h3><ul><li><p>总线架构（矩阵）</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105020077.png" alt="image-20210805105020077" loading="lazy"></li></ul></li><li><p>一致性维度</p><ul><li>一致性维度的范围是总线架构中的维度，即可能会在多个数据集市中都存在的维度，这个范围的选取需要架构师来决定。一致性维度的内容和普通维度并没有本质上区别，都是经过数据清洗和整合后的结果。</li><li>在同一个集市内，一致性维度的意思是两个维度如果有关系，要么就是完全一样的，要么就是一个维度在数学意义上是另一个维度的子集。</li></ul></li><li><p>一致性事实</p><ul><li>一致性事实主要需要保证两点。第一个是指标的定义及计算逻辑要一致，第二个是事实的单位要一致性。</li><li>在给指标命名时，如果所定义的两个指标完全一致时，应该取相同的名称，否则以不同的命名并给出解释。</li></ul></li></ul><h3 id="公共汇总层"><a href="#公共汇总层" class="headerlink" title="公共汇总层"></a>公共汇总层</h3><ul><li>将使用频繁的公用数据，通过聚集进行沉淀，比如卖家最近1天的交易汇总表、卖家最近N天的交易汇总表、卖家自然年交易汇总表等。这类聚集汇总数据，被叫作“公共汇总层”。</li></ul><h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><h3 id="模型层次"><a href="#模型层次" class="headerlink" title="模型层次"></a>模型层次</h3><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105031630.png" alt="image-20210805105031630" loading="lazy"></li></ul><h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105035924.png" alt="image-20210805105035924" loading="lazy"></li></ul><h2 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h2><h3 id="维度表技术基础"><a href="#维度表技术基础" class="headerlink" title="维度表技术基础"></a>维度表技术基础</h3><ul><li><p>维度的设计方法步骤</p><ul><li><p>选择维度或新建维度</p></li><li><p>确定主维表</p></li><li><p>确定相关维表</p></li><li><p>确定维度属性</p><ul><li>确定主维表的维度属性</li><li>确定相关维表的维度属性</li><li>合并</li></ul></li></ul></li><li><p>确定维度属性的几点提示</p><ul><li>尽可能丰富</li><li>多给出文字性描述的维度属性</li><li>区分数值型属性和事实</li><li>沉淀通用的（复杂）维度属性</li></ul></li><li><p>规范化与反规范化</p><ul><li><p>规范化：常见的规范化有数据库设计的三范式。</p><ul><li>第一范式1NF：指数据库的每一列都是不可分割的基本数据项，强调列的原子性</li><li>第二范式2NF：建立在第一范式的基础上还有两个条件，一是必须有一个（及以上）主键；二是没有包含在主键中的列必须全部依赖于全部主键，而不能只依赖于主键的一部分而不依赖全部主键。</li><li>第三范式3NF：基于2NF的基础上，另外还有满足非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列m既依赖于全部主键，又依赖于非主键列n的情况。</li></ul></li><li><p>反规范化：有如下几种常见的技术</p><ul><li><p>增加冗余列：常用来在查询时避免连接操作</p></li><li><p>增加派生列：增加可以通过表中其他数据计算生成的列。它的作用是在查询时减少计算量，从而加快查询速度。</p></li><li><p>重新组表：把这两个表重新组成一个表来减少连接而提高性能。</p></li><li><p>分割表</p><ul><li>水平分割</li><li>垂直分割</li></ul></li></ul></li></ul></li></ul><h3 id="维度表技术高级"><a href="#维度表技术高级" class="headerlink" title="维度表技术高级"></a>维度表技术高级</h3><ul><li><p>维度整合</p><ul><li><p>定义</p><ul><li>将两个表或多个表都有的字段放在主表中（主要基本信息），从属信息分别放在各自的从表中。对于主表中的主键,要么采用复合主键、源主键和系统或表区别标志；要么采用唯一主键、“源主键和系统或表区别标志”生成新的主键。通常建议采用复合主键的方式。</li></ul></li><li><p>垂直整合</p><ul><li>例如商品在业务系统中有多个表，商品档案、商品单位、商品分类等，这些表都属于商品相关信息表，依据维度设计方法，尽量整合至商品维度中，丰富其维度属性。</li></ul></li><li><p>水平整合</p><ul><li>例如业务系统中有商品档案，也有商城商品档案，两者之间可能存在交叉。是否需要将这两个表水平整合到同一个商品表呢？如果进行整合的话，需要考虑两种商品体系之间是否有交叉，如果存在交叉，则需要进行去重；如果不存在交叉，需要考虑两个商品体系的自然键是否存在冲突，如果不存在冲突，则可以考虑将各子集的自然键作为整合后的表的自然键；另一种方式是设置超自然键，将两个体系的自然键加工成一个字段作为超自然键。</li></ul></li></ul></li><li><p>维度拆分</p><ul><li><p>水平拆分</p><ul><li>将维度的不同分类实例化为不同的维度，同时在主维度中保存公共属性</li><li>维护单一维度，包含所有可能的属性。</li></ul></li><li><p>垂直拆分</p><ul><li>设计主从维度。主维表存放稳定、产出时间早、热度高的属性；从维表存放变化较快、产出时间晚、热度低的属性。</li></ul></li></ul></li><li><p>维度变化</p><ul><li><p>缓慢变化维</p><ul><li>定义：指的是维度的属性随着时间流逝，会发生缓慢的变化，对于缓慢变化维，有如下三种处理方式</li><li>重写维度值：不保留历史数据，始终取最新数据</li><li>插入新的维度行：保留历史数据，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联。</li><li>添加维度列：保留历史数据，对于需要分析历史信息的属性添加一列，来记录该属性变化前的值，而本属性字段使用TYPE 1来直接覆盖。</li></ul></li><li><p>快照维表</p><ul><li>针对维表，每天（或者其他周期）进行一次快照</li></ul></li><li><p>极限存储</p><ul><li>由于快照维表占用内存大，提出使用拉链表来解决这个问题</li></ul></li><li><ul><li>微型维度</li></ul></li><li><p>递归层次</p><ul><li><p>两种处理方式</p><ul><li>层次结构扁平化</li><li>层次桥接表</li></ul></li></ul></li></ul></li><li><p>特殊维度</p><ul><li><p>行为维度</p><ul><li><p>定义：和事实相关的维度，如交易、物流等维度，称为行为维度，或事实衍生的维度</p></li><li><p>行为维度的划分</p><ul><li>过去行为，如买家最近一次访问淘宝时间，最后一次交易时间。</li><li>快照事实行为维度，如买家至今的交易金额，信用分值。</li><li>分组事实行为维度，就是将上面的数值型数据转换为枚举型，例如将信用分转为信用等级。</li><li>复杂逻辑事实行为维度，通过复杂加工得到。</li></ul></li><li><p>两种处理方式</p><ul><li>可以将维度冗余至现有的维度表中，比如将买家信用等级冗余至买家维度表。</li><li>也可以加工成单独的行为维度，如：卖家主营类目维度。</li></ul></li><li><p>参考原则</p><ul><li>避免维度过快增长</li><li>避免维度过快增长</li></ul></li></ul></li><li><p>多值维度</p><ul><li><p>定义：事实表中的一行对应维度表中多行的情况，产生多值维度。</p></li><li><p>三种处理方式</p><ul><li>降低事实表的粒度：如将交易订单设计为子订单粒度，对于每个交易订单，只有一个商品与之对应，对于其中的事实，则采用分摊的方式。</li><li>使用多字段：在事实表中增加多个字段来标记同一个订单的同种维度值</li><li>使用较为通用的桥接表：通过在事实表和维表之间开发一个分组表，通过此分组表建立连接。</li></ul></li></ul></li><li><p>多值属性</p><ul><li><p>定义：维表中的某个属性字段同时有多个值，这种情况称之为“多值属性”。</p></li><li><p>三种处理方式</p><ul><li>保持维度主键不变，将多值属性放在维度的一个属性字段中。如通过k-v的形式：<code>12:2212; 13:13144; 14:12444</code></li><li>保持维度主键不变，将多值属性放在维度的多个属性字段中。</li><li>维度主键发生变化，一个维度值存放多条记录。比如商品的sku维表，对于每个商品有多少sku,就有多少条记录，主键是商品ID 和SKU的 ID。</li></ul></li></ul></li><li><p>杂项维度</p><ul><li>杂项维度是由操作系统中的指示符或者标志字段组合而成，一般不在一致性维度之列。</li><li>杂项维度一般是逻辑模型，不进行物理化实现，杂项维度和其他维度一起，会将维度属性退化至事实表中，详情在事实表中描述。</li></ul></li></ul></li></ul><h2 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h2><h3 id="事实表技术基础"><a href="#事实表技术基础" class="headerlink" title="事实表技术基础"></a>事实表技术基础</h3><ul><li><p>事实表特性</p><ul><li><p>事实的类型</p><ul><li>可加型：可以按照任意维度进行汇总</li><li>半可加型：只能按照某些维度进行汇总</li><li>不可加型</li></ul></li></ul></li><li><p>事实表设计原则</p><ul><li><p>尽可能包含所有与业务过程相关的事实</p><p>在事实表中应该尽量包含所有与业务过程相关的事实，即使存在冗余，但是因为事实通常为数字型，带来的存储开销也不会很大。</p></li><li><p>只选择与业务过程相关的事实</p></li></ul><p>如：在订单的下单这个业务过程的事实表设计中，不应该存在支付金额这个表示支付业务过程的事实。</p><ul><li>分解不可加性事实为可加的组件</li></ul><p>如：订单的优惠率，应该分解为订单原价金额与订单优惠金额两个事实存储在事实表中。</p><ul><li>在选择维度和事实之前必须先声明粒度</li></ul><p>粒度用于确定事实表中一行所表示业务的细节层次，决定了维度模型的扩展性，在选择维度和事实之前必须先声明粒度，且每个维度和事实必须与所定义的粒度保持一致。在设计事实表的过程中，粒度定义的越细越好，一般从原子粒度开始。在事实表中，通常通过业务描述来表述粒度，对于聚集性事实表的粒度描述，可采用维度或维度属性组合的方式。</p><ul><li><p>在同一个事实表中不能有多种不同粒度的事实</p><p>事实表中的所有事实需要与表定义的粒度保持一致。如：机票支付成功事务事实表，粒度为票一级的，而在实际业务中，一个订单可以同时支付多张票，如ID为100901的订单包含三张机票，ID为100902的订单包含两张机票，ID为100903的订单包含一张机票。在该事实表的设计中，票支付金额和票折扣金额两个事实与表定义的粒度一致，并且支持按表的任意维度汇总，可以添加进该事实表中。而订单支付金额和订单票数作为上一层粒度的订单级事实，与该票级事实表的粒度不一致，且不能进行汇总。比如订单ID为100901的订单支付金额为3700元，订单票数为3张，如果这两个度量在该表进行汇总计算总订单金额和总票数，则会造成重复计算的问题，所以不能作为该表的度量选入。</p></li></ul></li><li><p>事实的单位要保持一致</p><p>对于同一个事实表中事实的单位，应该保持一致。比如原订单金额、订单优惠金额、订单运费金额这三个事实，应该采用一致的计量单位，统一为元或分，以方便使用。</p></li><li><p>对事实的null值要处理</p><p>对于事实表中事实度量为null 值的处理，因为在数据库中null 值对常用数字型字段的sql过滤条件都不生效，比如大于、小于、等于、大于或等于、小于或等于，建议用零值填充。</p></li><li><p>使用退化维度提高事实表的易用性</p><p>在Kimball的维度建模中，通常按照星形模型的方式来设计，对于维度的获取采用的是通过事实表的外键关联专门的维表的方式，谨慎使用退化维度。而在大数据领域的事实表设计中，则<b>大量采用退化维度的方式，在事实表中存储各种类型的常用维度信息。<b>这样设计的目的主要是为了</b>减少下游用户使用时关联多个表的操作</b>，直接通过退化维度实现对事实表的过滤查询、控制聚合层次、排序数据以及定义主从关系等。通过增加冗余存储的方式减少计算开销，提高使用效率。</p></li><li><p>事实表设计方法</p><ul><li><p>第一步：选择业务过程及确定事实表类型</p><p>​    在选择了业务过程以后，相应的事实表类型也随之确定了。比如选择买家付款这个业务过程，那么事实表应为只包含买家付款这一个业务过程的单事务事实表；如果选择的是所有四个业务过程，并且需要分析各个业务过程之间的时间间隔，那么所建立的事实表应为包含了所有四个业务过程的累积快照事实表。</p></li><li><p>第二步：声明粒度</p></li></ul><p>​    粒度的声明是事实表建模非常重要的一步，意味着精确定义事实表的每一行所表示的业务含义，粒度传递的是与事实表度量有关的细节层次。明确的粒度能确保对事实表中行的意思的理解不会产生混淆，保证所有的事实按照同样的细节层次记录。<br>  ​    应该尽量选择最细级别的原子粒度，以确保事实表的应用具有最大的灵活性。同时对于订单过程而言，粒度可以被定义为最细的订单级别。比如在淘宝订单中有父子订单的概念，即一个子订单对应一种商品，如果拍下了多种商品，则每种商品对应一个子订单；这些子订单一同结算的话，则会生成一个父订单。那么在这个例子中，事实表的粒度应该选择为子订单级别。</p><ul><li><p>第三步：确定维度</p><p>​    完成粒度声明以后，也就意味着确定了主键，对应的维度组合以及相关的维度字段就可以确定了，应该选择能够描述清楚业务过程所处的环境的维度信息。比如在淘宝订单付款事务事实表中，粒度为子订单，相关的维度有买家、卖家、商品、收货人信息、业务类型、订单时间等维度。</p></li><li><p>第四步：确定事实</p><p>​    事实可以通过回答“过程的度量是什么”来确定。应该选择与业务过程有关的所有事实，且事实的粒度要与所声明的事实表的粒度一致。事实有可加性、半可加性、非可加性三种类型，需要将不可加性事实分解为可加的组件。<br>​    比如在淘宝订单付款事务事实表中，同粒度的事实有子订单分摊的支付金额、邮费、优惠金额等。</p></li><li><p>第五步：冗余维度</p><p>​    在传统的维度建模的星形模型中，对维度的处理是需要单独存放在专门的维表中的，通过事实表的外键获取维度。这样做的目的是为了减少事实表的维度冗余，从而减少存储消耗。<br>​    而在大数据的事实表模型设计中，考虑更多的是提高下游用户的使用效率，降低数据获取的复杂性，减少关联的表数量。所以通常事实表中会冗余方便下游用户使用的常用维度，以实现对事实表的过滤查询、控制聚合层次、排序数据以及定义主从关系等操作。比如在淘宝订单付款事务事实表中，通常会冗余大量的常用维度字段，以及商品类目、卖家店铺等维度信息。</p></li></ul></li></ul><h3 id="事实表技术高级"><a href="#事实表技术高级" class="headerlink" title="事实表技术高级"></a>事实表技术高级</h3><ul><li><p>三种事实表</p><ul><li><p>事务事实表</p><ul><li><p>设计过程</p><ul><li>第一步：选择业务过程</li><li>第二步：声明粒度</li><li>第三步：确定维度</li><li>第四步：确定事实</li><li>第五步：冗余维度</li></ul></li><li><p>单事务事实表</p><ul><li>定义：即对每个业务过程设计一个事实表，这样可以方便对每个业务过程进行独立的分析研究。</li></ul></li><li><p>多事务事实表</p><ul><li><p>定义：将不同的事实放到同一个事实表中，即同一个事实表包含不同的业务过程。</p></li><li><p>多事实事务表的多个业务过程的标记方式</p><ul><li>针对每一个业务过程打一个标签，标签之间互不相干。</li></ul></li><li><p>多事务的处理方式</p><ul><li>对每个度量都使用一个字段进行保存，即不同的事实使用不同的字段进行存放。如果不是当前业务过程的度量，则采取“置零”的处理方式。</li><li>使用同一个字段存放不同业务过程的事实，使用标签字段来区分不同业务过程。</li></ul></li><li><p>处理方式的选择</p><ul><li>第一种方案适用于不同业务过程的度量差异较大。</li><li>第二种方案适用于不同业务过程的度量相似、差异不大。</li></ul></li></ul></li><li><p>两种事务事实表的对比</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105057823.png" alt="image-20210805105057823" loading="lazy"></li></ul></li><li><p>父子事实的处理方式</p><ul><li>以父子交易订单为例，将下单总额或者支付总额分摊到每个子订单上，当然只有一个子订单时是不需要进行分摊的。</li></ul></li><li><p>事实的设计准则</p><ul><li>完整性：事实表应尽可能包含与其描述的过程有关的所有事实，即尽可能多地获取所有的度量。</li><li>一致性：在确定事务事实表的事实时，明确存储每一个事实以确保度量的一致性。</li><li>可加性：针对非可加性事实，应存储拆分后的可加性事实（如果可以拆分的话）</li></ul></li></ul></li><li><p>周期快照事实表</p><ul><li><p>定义：快照事实表以预定的时间间隔采样状态度量，这种间隔联合一个及以上的维度，将被用来定义快照事实表的粒度，每行都将包含记录所涉及状态的事实。</p></li><li><p>与事务事实表的区别</p><ul><li><p>事务事实表的粒度能以多种方式表达，但快照事实表的粒度通常以维度形式声明；</p></li><li><p>事务事实表是稀疏的，但快照事实表是稠密的；</p><p>只有当天发生的业务过程，事实表才会记录该业务过程的事实，如下单、支付等；而快照事实表是稠密的，无论当天是否有业务过程发生，都会记录一行，比如针对卖家的历史至今的下单和支付金额，无论当天卖家是否有下单支付事实，都会给该卖家记录一行。稠密性是快照事实表的重要特征，如果在每个快照周期内不记录行，比如和事务事实表一样，那么确定状态将变得非常困难。</p></li><li><p>事务事实表中的事实是完全可加的，但快照模型将至少包含一个用来展示半可加性的事实。</p></li></ul></li><li><p>设计过程</p><ul><li>确定快照粒度</li><li>确定采样的状态度量</li></ul></li><li><p>案例</p><ul><li><p>单维度的每天快照事实表</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105106577.png" alt="image-20210805105106577" loading="lazy"></li></ul></li><li><p>混合维度的每天快照事实表</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105109609.png" alt="image-20210805105109609" loading="lazy"></li></ul></li><li><p>全量快照事实表</p><ul><li><p>设计过程</p><ul><li>确定快照粒度</li><li>确定采样的状态度量</li><li>冗余维度：如好中评快照事实表，冗余了子订单维度、商品维度、评论者维度、被评论维度以及杂项维度 ，包括评论内容、是否匿名等信息</li></ul></li><li><p><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105114002.png" alt="image-20210805105114002" loading="lazy"></p></li></ul></li></ul></li><li><p>注意事项</p><ul><li>事务事实表与周期快照事实表成对设计</li><li>附加事实，可以附加一些上一个采样周期的状态度量</li><li>周期到日期度量，如：历史至今、自然年至今、季度至今、财年至今等状态度量</li></ul></li></ul></li><li><p>累积快照事实表</p><ul><li><p>设计过程</p><ul><li>第一步：选择业务过程</li><li>第二步：声明粒度</li><li>第三步：确定维度</li><li>第四步：确定事实</li><li>第五步：冗余维度</li></ul></li><li><p>特性</p><ul><li><p>数据不断更新</p><ul><li><p>事务事实表记录事务发生时的状态，对于实体的某一实例不再更新；而累计快照事实表则对实体的某一实例定期更新。</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105120393.png" alt="image-20210805105120393" loading="lazy"></li></ul></li></ul></li><li><p>多业务过程日期，用于计算业务过程之间的时间间隔</p></li><li><p>保存全量数据，以代替ODS层源数据，在使用时，减少表之间的关联</p></li></ul></li><li><p>特殊处理</p><ul><li><p>非线性过程</p><ul><li><p>定义：业务过程并不是线性进行的，如正常的流程是：下单-&gt;支付-&gt;发货-&gt;确认收货-&gt;关闭订单。实际上可能出现下单-&gt;关闭订单、下单-&gt;支付-&gt;关闭订单等情况。</p></li><li><p>处理方式</p><ul><li>业务过程的统一：如流程结束标志的统一（如交易结束包括交易完成和交易关闭两种情况）</li><li>针对业务关键里程碑构建全面的流程：对于没有走完全部流程的，可以将相关业务过程的时间和事实进行置空处理。</li><li>循环流程的处理：主要解决一个业务过程存在多个里程碑日期的问题，选取哪一个日期的决定权在于商业用户而不是设计或开发。</li></ul></li></ul></li><li><p>多源过程</p><ul><li>定义：针对多业务过程建模时，业务过程可能来自不同的数据域或数据表，虽然对累计快照事实表的模型设计没有影响，但是会影响ETL开发的负责度</li><li>针对多源业务建模，主要考虑事实表的粒度。</li></ul></li><li><p>业务过程取舍</p><ul><li>对于某个累积快照事实表，不一定要实现所有的业务过程。</li></ul></li></ul></li><li><p>三种物理实现方式</p><ul><li><p>全量表的形式</p><ul><li>适用于全量数据较少的情况</li><li>实现：一般以日期为分区表，每天的分区存储昨天的全量数据和当天的增量数据合并的结果，保证每条记录的状态最新。</li></ul></li><li><p>全量表的变化形式</p><ul><li>适用于事实表数据量很大的情况</li><li>确定业务实体从产生到消亡的时间间隔，设计该时间间隔的累积快照事实表，每天的分区存储最近该时间间隔的数据，之前的数据存储在归档表中。</li></ul></li><li><p>以业务实体的结束时间分区</p><ul><li>每天的分区存放当天结束的数据，另外设计一个时间非常大的分区，存放截至当前未结束的数据。</li><li>优点：时间大的分区数据量不会很大，ETL性能好，并且无存储浪费，对于某些业务实体的某具体实例，在该表的全量数据中唯一。</li></ul></li></ul></li><li><p>案例</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105126872.png" alt="image-20210805105126872" loading="lazy"></li></ul></li></ul></li></ul></li><li><p>三种事实表的对比</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105155518.png" alt="image-20210805105155518" loading="lazy"></li><li>累积快照事实表适用于具有较明确起止时间的短生命周期的实体；对于商品、用户等具有长生命周期的实体，一般采用周期快照事实表更合适。</li></ul></li><li><p>无事实的事实表</p><ul><li><p>定义：事实表用事实来度量业务过程，不包含事实或度量的事实表称为“无事实的事实表”。</p></li><li><p>存在形式</p><ul><li>第一种是事件类的，记录事件的发生。</li><li>第二种是条件、范围或资格类的，记录维度与维度多对多之间的关系。比如客户和销售人员的分配情况、产品的促销范围等。</li></ul></li></ul></li><li><p>公共汇总层的设计</p><ul><li><p>聚集的定义：聚集是指针对原始明细粒度的数据进行汇总。</p></li><li><p>聚集型事实表</p><ul><li><p>聚集基本原则</p><ul><li>一致性：聚集表必须提供与查询明细粒度数据一致的查询结果。从设计角度来看，确保一致性，最简单的方法是确保聚集星形模型中的维度和度量与原始模型中的维度和度量保持一致。</li><li>避免同一字段存储多个层次的数据：在聚集时显式地加入数据层级列以示区别，但是这样会加大使用者的使用成本。行之有效的另一种方法是把按天与按月汇总的交易额用两列存放，但是需要在列名或者列注释上能分辨出来。</li><li>聚集粒度可不同：聚集并不需要保持与原始明细粒度数据一样的粒度，聚集只关心所需要查询的维度。可以按照卖家汇总一天的营业额(交易额)，也可以按照商品与地域汇总一月的交易额。</li></ul></li><li><p>聚集的基本步骤</p><ul><li><p>第一步：确定聚集维度</p><p>​    在原始明细模型中会存在多个描述事实的维度，如日期、商品类别、卖家等，这时候需要确定根据什么维度聚集，如果只关心商品的交易额情况，那么就可以根据商品维度聚集数据。</p></li><li><p>第二步：确定一致性上钻</p></li></ul></li></ul></li></ul><p>​    这时候要关心是按月汇总还是按天汇总，是按照商品汇总还是按照类目汇总，如果按照类目汇总，还需要关心是按照大类汇总还是小类汇总。当然，我们要做的只是了解用户需要什么，然后按照他们想要的进行聚集。<br>​          </p><pre><code>    - 第三步：确定聚集事实      ​    在原始明细模型中可能会有多个事实的度量，比如在交易中有交易额、交易数量等，这时候要明确是按照交易额汇总还是按照成交数量汇总。</code></pre></li></ul><p>  ​    </p><ul><li><p>公共汇总层其他原则</p><ul><li><p>原则</p><ul><li>数据公用性</li></ul></li><li><p>不要跨数据域</p><ul><li>区分统计周期，在表的命名上要体现统计周期</li></ul></li><li><p>案例</p><ul><li><p>原始的明细模型</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105205851.png" alt="image-20210805105205851" loading="lazy"></li></ul></li><li><p>按潜在的维度进行聚集（只展示一部分）</p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105209541.png" alt="image-20210805105209541" loading="lazy"></li></ul></li><li><p><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105211821.png" alt="image-20210805105211821" loading="lazy"></p><ul><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105214422.png" alt="image-20210805105214422" loading="lazy"></li><li><img src="/2021/08/05/dw-dimensional-modeling-04/image-20210805105218519.png" alt="image-20210805105218519" loading="lazy"></li></ul></li></ul></li></ul></li><li><p>聚集补充说明</p><ul><li><p>聚集是不跨越事实的</p><ul><li>聚集是针对原始星形模型进行的汇总,为了获取和查询与原始模型一致的结果，聚集的维度和度量必须与原始模型保持一致，因此聚集是不跨越事实的。</li></ul></li><li><p>横向钻取是针对多个事实基于一致性维度进行的分析，很多时候采用融合事实表,预先存放横向钻取的结果，从而提高查询性能。因此，融合事实表是一种导出模式而不是聚集。</p></li><li><p>聚集带来的问题</p><ul><li>聚集会带来查询性能的提升，但聚集也会增加ETL维护的难度。如当子类目对应的一级类目发生变更时，先前存在的、已经被汇总到聚集表中的数据需要被重新调整。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 维度建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事实表设计</title>
      <link href="2021/08/05/dw-dimensional-modeling-03/"/>
      <url>2021/08/05/dw-dimensional-modeling-03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="事实表基础"><a href="#事实表基础" class="headerlink" title="事实表基础"></a>事实表基础</h3><blockquote><p>参考：</p><p>Star Schema–The Complete Reference</p><p>The Data Warehouse Toolkit-The Definitive Guide to Dimensional Modeling</p></blockquote><h4 id="事实表特性"><a href="#事实表特性" class="headerlink" title="事实表特性"></a>事实表特性</h4><p>事实表围绕业务过程来设计，内容包含引用的<strong>维度</strong>和与业务过程有关的<strong>度量</strong>。事实表一条记录所表达的业务细节程度被称为<strong>粒度</strong>。通常粒度表述为：维度属性组合所表示的细节程度 或 所表示的具体业务含义。</p><p>​    <strong>事实</strong>一般为整型或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。</p><ul><li><strong>可加型：</strong>事实可以按照与事实表关联的任意维度进行汇总。</li><li><strong>半可加性：</strong>事实只能按照特定维度进行汇总。</li><li><strong>不可加型：</strong>不可加性事实可以分解为可加的组件来实现聚集。</li></ul><blockquote><p>相较于维度表，事实表要细长得多，行的增加速度也比维表快很多。</p></blockquote><p><strong>退化维度的概念：</strong>维度属性也可以存储到事实表中，这种存储到事实表中的维度列就被称为“退化维度”。与其他存储在维度表中的维度一样，<strong>退化维度也可以用来进行事实表的过滤查询、实现聚合操作等。</strong></p><a id="more"></a><h4 id="事实表设计原则"><a href="#事实表设计原则" class="headerlink" title="事实表设计原则"></a>事实表设计原则</h4><ul><li>尽可能包含所有与业务过程相关的事实；</li></ul><blockquote><p>在事实表中应该尽量包含所有与业务过程相关的事实，即使存在冗余，但是因为事实通常为数字型，带来的存储开销也不会很大。</p></blockquote><ul><li>只选择与业务过程相关的事实</li></ul><blockquote><p>如：在订单的下单这个业务过程的事实表设计中，不应该存在支付金额这个表示支付业务过程的事实。</p></blockquote><ul><li>分解不可加性事实为可加的组件</li></ul><blockquote><p>如：订单的优惠率，应该分解为订单原价金额与订单优惠金额两个事实存储在事实表中。</p></blockquote><ul><li>在选择维度和事实之前必须先声明粒度</li></ul><blockquote><p>粒度用于确定事实表中一行所表示业务的细节层次，决定了维度模型的扩展性，在选择维度和事实之前必须先声明粒度，且每个维度和事实必须与所定义的粒度保持一致。在设计事实表的过程中，粒度定义的越细越好，一般从原子粒度开始。在事实表中，通常通过业务描述来表述粒度，对于聚集性事实表的粒度描述，可采用维度或维度属性组合的方式。</p></blockquote><ul><li>在同一个事实表中不能有多种不同粒度的事实</li></ul><blockquote><p>事实表中的所有事实需要与表定义的粒度保持一致。</p><p>如：机票支付成功事务事实表，粒度为票一级的，而在实际业务中，一个订单可以同时支付多张票，如ID为100901的订单包含三张机票，ID为100902的订单包含两张机票，ID为100903的订单包含一张机票。在该事实表的设计中，票支付金额和票折扣金额两个事实与表定义的粒度一致，并且支持按表的任意维度汇总，可以添加进该事实表中。而订单支付金额和订单票数作为上一层粒度的订单级事实，与该票级事实表的粒度不一致，且不能进行汇总。比如订单ID为100901的订单支付金额为3700元，订单票数为3张，如果这两个度量在该表进行汇总计算总订单金额和总票数，则会造成重复计算的问题，所以不能作为该表的度量选入。</p></blockquote><ul><li>事实的单位要保持一致</li></ul><blockquote><p>对于同一个事实表中事实的单位，应该保持一致。比如原订单金额、订单优惠金额、订单运费金额这三个事实，应该采用一致的计量单位，统一为元或分，以方便使用。</p></blockquote><ul><li>对事实的null值要处理</li></ul><blockquote><p>对于事实表中事实度量为null 值的处理，因为在数据库中null 值对常用数字型字段的sql过滤条件都不生效，比如大于、小于、等于、大于或等于、小于或等于，建议用零值填充。</p></blockquote><ul><li>使用退化维度提高事实表的易用性</li></ul><blockquote><p>在Kimball的维度建模中，通常按照星形模型的方式来设计，对于维度的获取采用的是通过事实表的外键关联专门的维表的方式，谨慎使用退化维度。而在大数据领域的事实表设计中，则<strong>大量采用退化维度的方式，在事实表中存储各种类型的常用维度信息。</strong>这样设计的目的主要是为了<strong>减少下游用户使用时关联多个表的操作</strong>，直接通过退化维度实现对事实表的过滤查询、控制聚合层次、排序数据以及定义主从关系等。通过增加冗余存储的方式减少计算开销，提高使用效率。</p></blockquote><h4 id="事实表设计方法"><a href="#事实表设计方法" class="headerlink" title="事实表设计方法"></a>事实表设计方法</h4><blockquote><p>在kimball维度建模理论中，对于维度模型设计采用四步设计方法：选择业务过程、声明粒度、确定维度和确定事实。在互联网大数据环境下，为了面对复杂的业务场景，为了更有效、更准确地进行维度模型设计，对kimball维度建模方法进行了改进：</p></blockquote><h5 id="第一步：选择业务过程及确定事实表类型"><a href="#第一步：选择业务过程及确定事实表类型" class="headerlink" title="第一步：选择业务过程及确定事实表类型"></a>第一步：选择业务过程及确定事实表类型</h5><p>​    在明确了业务需求以后，接下来需要进行详细的需求分析，对业务的整个生命周期进行分析，明确关键的业务步骤，从而选择与需求有关的业务过程。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210426153556020.png" alt="image-20210426153556020" loading="lazy"></p><p>​    业务过程通常使用<strong>行为动词表示业务执行的活动</strong>。比如图 11.1中的淘宝订单流转的业务过程有四个:<strong>创建订单、买家付款、卖家发货、买家确认收货</strong>。在明确了流程所包含的业务过程后，需要<strong>根据具体的业务需求来选择与维度建模有关的业务过程</strong>。比如是选择买家付款这个业务过程，还是选择创建订单和买家付款这两个业务过程，具体<strong>根据业务情况来确定</strong>。<br>​    在选择了业务过程以后，相应的事实表类型也随之确定了。比如选择买家付款这个业务过程，那么事实表应为只包含买家付款这一个业务过程的<u>单事务事实表</u>；如果选择的是所有四个业务过程，并且需要分析各个业务过程之间的时间间隔，那么所建立的事实表应为包含了所有四个业务过程的<u>累积快照事实表</u>。</p><h5 id="第二步：声明粒度"><a href="#第二步：声明粒度" class="headerlink" title="第二步：声明粒度"></a>第二步：声明粒度</h5><p>​    粒度的声明是事实表建模非常重要的一步，意味着精确定义事实表的每一行所表示的业务含义，粒度传递的是与事实表度量有关的细节层次。明确的粒度能确保对事实表中行的意思的理解不会产生混淆，保证所有的事实按照同样的细节层次记录。<br>​    应该尽量<strong>选择最细级别的原子粒度</strong>，以确保事实表的应用具有最大的灵活性。同时对于订单过程而言，粒度可以被定义为最细的订单级别。比如在淘宝订单中有父子订单的概念，即一个子订单对应一种商品，如果拍下了多种商品，则每种商品对应一个子订单；这些子订单一同结算的话，则会生成一个父订单。那么在这个例子中，事实表的粒度应该选择为子订单级别。</p><h5 id="第三步：确定维度"><a href="#第三步：确定维度" class="headerlink" title="第三步：确定维度"></a>第三步：确定维度</h5><p>​    完成粒度声明以后，也就意味着确定了主键，对应的维度组合以及相关的维度字段就可以确定了，应该选择能够描述清楚业务过程所处的环境的维度信息。<u>比如在淘宝订单付款事务事实表中，粒度为子订单，相关的维度有买家、卖家、商品、收货人信息、业务类型、订单时间等维度。</u></p><h5 id="第四步：确定事实"><a href="#第四步：确定事实" class="headerlink" title="第四步：确定事实"></a>第四步：确定事实</h5><p>​    事实可以通过回答“过程的度量是什么”来确定。应该选择<u>与业务过程有关的</u><strong>所有事实</strong>，且事实的粒度要与所声明的事实表的粒度一致。事实有可加性、半可加性、非可加性三种类型，需要将不可加性事实分解为可加的组件。<br>​    比如在淘宝订单付款事务事实表中，同粒度的事实有子订单分摊的支付金额、邮费、优惠金额等。</p><h5 id="第五步：冗余维度"><a href="#第五步：冗余维度" class="headerlink" title="第五步：冗余维度"></a>第五步：冗余维度</h5><p>​    在传统的维度建模的星形模型中，对维度的处理是需要单独存放在专门的维表中的，通过事实表的外键获取维度。这样做的目的是为了减少事实表的维度冗余，从而减少存储消耗。</p><p>​    而在大数据的事实表模型设计中，考虑更多的是提高下游用户的使用效率，降低数据获取的复杂性，减少关联的表数量。所以通常事实表中会冗余方便下游用户使用的常用维度，以实现对事实表的过滤查询、控制聚合层次、排序数据以及定义主从关系等操作。比如在淘宝订单付款事务事实表中，通常会冗余大量的常用维度字段，以及商品类目、卖家店铺等维度信息。</p><h3 id="事务事实表"><a href="#事务事实表" class="headerlink" title="事务事实表"></a>事务事实表</h3><blockquote><p>用来描述业务过程，跟踪空间或时间上某点的度量事件，保存的是原子数据。</p><p>订单作为交易行为的核心载体，直观反映了交易的状况。订单的流转会产生很多业务过程，而下单、支付和成功完结三个业务过程是整个订单的关键节点。获取这三个业务过程的笔数、金额以及转化率是日常数据统计分析的重点，事务事实表设计可以很好地满足这个需求。本节将介绍三种不同事务事实表的设计方式，以及在淘宝交易订单中关于邮费和折扣分摊到子订单的算法。</p></blockquote><h4 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h4><p>​    任何类型的事件都可以被理解为一种事务。比如交易过程中的创建订单、买家付款，物流过程中的揽货、发货、签收，退款中的申请退款、申请小二介入等，都可以被理解为一种事务。事务事实表，即针对这些过程构建的一类事实表，用以跟踪定义业务过程的个体行为，提供丰富的分析能力，作为数据仓库原子的明细数据。下面以淘宝交易事务事实表为例，阐述事务事实表的一般设计过程。</p><h5 id="1-选择业务过程"><a href="#1-选择业务过程" class="headerlink" title="1) 选择业务过程"></a>1) 选择业务过程</h5><p>图11.1中出现了创建订单、买家付款、卖家发货、买家确认收货四个业务过程，这四个业务过程不仅是交易过程中的重要时间点，也是统计分析的重点，因此交易事务事实表设计着重从这四个业务过程进行展开。</p><blockquote><p>Kimball 维度建模理论认为，为了便于进行独立的分析研究，应该为每个业务过程建立一个事实表。对于是否将不同业务过程放到同一个事实表中，将在下一节中详细介绍。</p></blockquote><h5 id="2-确定粒度"><a href="#2-确定粒度" class="headerlink" title="2) 确定粒度"></a>2) 确定粒度</h5><p>即确定事务事实表每一行所表达的细节层次。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210426171658295.png" alt="image-20210426171658295" loading="lazy"></p><p>​    淘宝出售商品主要分两类卖家:一类是个人性质的闲置卖家，主要出售闲置的或者二手商品；一类是拥有店铺的卖家，以出售新商品为主。接下来主要以店铺类交易订单为例进行介绍。在淘宝下单交易时，有两种方式:一种是选定商品后直接购买，这样会产生一个交易订单；一种是将多种商品加入到购物车中，然后一起结算，此时对于每一种商品都会产生一个订单，同时对于同一个店铺会额外产生一个订单，即<strong>父订单</strong>；由于是在同一个店铺购买的，所以父订单会承载订单物流、店铺优惠等信息。而对于每一种商品产生的订单就称为子订单，子订单记录了父订单的订单号，并且有子订单标志。如果在同一个店铺只购买了一种商品，则会将父子订单进行合并，只保留一条订单记录。如图11.2和图11.3所示示例。</p><p>​    了解了淘宝交易订单的产生过程后，现在为淘宝交易事务事实表确定粒度。如第1步所述，在淘宝交易过程中有四个重要业务过程，需要为每个业务过程确定一个粒度。其中<strong>下单、支付和成功完结三个业务过程选择交易子订单粒度</strong>，即每个子订单为事务事实表的一行，每个子订单所表达的细节信息为:交易时间、卖家、买家、商品，即选择图11.2和图11.3中订单ID为1、4、5、6、7、8、9的子订单作为事务事实表的每一行。卖家发货这个业务过程可以选择子订单粒度，即将每个子订单作为卖家发货事实表的一个细节。然而，在实际操作中发现，<strong>卖家发货更多的是物流单粒度而非子订单粒度</strong>，同一个子订单可以拆开成多个物流单进行发货。在事务事实表设计过程中，秉承确定为最细粒度的原则，<strong>因此对于卖家发货确定为物流单粒度</strong>，和其他三个业务过程不同，这样可以更好地给下游统计分析带来灵活性。</p><h5 id="3-确定维度"><a href="#3-确定维度" class="headerlink" title="3) 确定维度"></a>3) 确定维度</h5><p>​    选定好业务过程并且确定粒度后，就可以确定维度信息了。在淘宝交易事务事实表设计过程中，按照经常用于统计分析的场景，<strong>确定维度包含:买家、卖家、商品、商品类目、发货地区、收货地区、父订单维度以及杂项维度</strong>。由于订单的属性较多，比如订单的业务类型、是否无线交易、订单的attributes属性等，对于这些使用较多却又无法归属到上述买卖家或商品维度中的属性，则新建一个杂项维度进行存放，如图11.4所示。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210426171943189.png" alt="image-20210426171943189" loading="lazy"></p><p>​    选定好业务过程并且确定粒度后，就可以确定维度信息了。在淘宝交易事务事实表设计过程中，按照经常用于统计分析的场景，确定维度包含:买家、卖家、商品、商品类目、发货地区、收货地区、父订单维度以及杂项维度。由于订单的属性较多，比如订单的业务类型、是否无线交易、订单的attributes属性等，对于这些使用较多却又无法归属到上述买卖家或商品维度中的属性，则新建一个杂项维度进行存放，如图11.4所示。</p><h5 id="4-确定事实"><a href="#4-确定事实" class="headerlink" title="4) 确定事实"></a>4) 确定事实</h5><p>​    事实表应该包含与其描述过程有关的所有事实。以交易事务事实表为例，选定三个业务过程——下单、支付和完成，不同的业务过程有着不同的事实。比如在下单业务过程中，需要包含下单金额、下单数量、下单分摊金额；在支付业务过程中，包含支付金额、分摊邮费、折扣金额、红包金额、积分金额；在完结业务过程中包含确认收货金额等。由于粒度是子订单，所以对于一些父订单上的金额需要分摊到子订单上，比如父订单邮费、父订单折扣等。具体的分摊算法将在“父子事实的处理方式”一节中介绍。</p><p>​    出于效率和资源的考虑，将常用维度全部退化到事实表，使得下游分析使用模型更加方便。</p><h5 id="5-冗余维度"><a href="#5-冗余维度" class="headerlink" title="5) 冗余维度"></a>5) 冗余维度</h5><p>​    在确定维度时，包含了买卖家维度、商品维度、类目维度、收发货维度等，Kimball建议在事实表中只保存这些维表的外键，而在淘宝交易事务表中，将买卖家星级、标签、店铺名称、商品类型、商品特征、商品属性、类目层级等维度属性都冗余到事实表中，提高对事实表进行过滤查询、统计聚合的效率，如下图所示：</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427104129207.png" alt="image-20210427104129207" loading="lazy"></p><p>​    经过以上5个步骤，完成了淘宝交易事务事实表的设计。但是还有一个遗留问题：对于单一事实表中是否包含多个业务过程，还没有给出定论。</p><h4 id="单事务事实表"><a href="#单事务事实表" class="headerlink" title="单事务事实表"></a>单事务事实表</h4><blockquote><p>单事务事实表，即对每个业务过程设计一个事实表，这样可以方便对每个业务过程进行独立的分析研究。</p></blockquote><p>​    以1688交易过程为例：其流程也是包括下单、支付、发货和完结，在这四个关键流程中选择下单和支付两个业务过程设计事务事实表：1688交易订单下单事务事实表和1688交易订单支付事务事实表。</p><p>​    选定业务过程后，对每个业务过程确定粒度、维度和事实。</p><p>​    对于1688交易订单下单事务事实表：</p><ul><li>粒度：子订单粒度</li><li>维度：买家、卖家、商品、父订单、收获地区维度</li><li>事实：下单分摊金额和折扣金额</li></ul><p>​    对于1688交易订单支付事务事实表：</p><ul><li>粒度：子订单粒度</li><li>维度：买家、卖家、商品、父订单、收获地区维度</li><li>事实：支付金额、支付调整金额和支付优惠等</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427123816087.png" alt="image-20210427123816087" loading="lazy"></p><p>​    下面以具体交易订单为例，展示单事务事实表的设计实例。如图11.8所示，order1在2016-01-01下单并且在当天完成支付；order2和order3在2016-01-01下单并且在2016-01-02完成支付。如图11.9和图11.10所示，orderl 、order2和order3写入下单事务事实表中，业务日期（下单日期）均为2016-01-01；order1、 order2和 order3也分别写入支付事务事实表中，业务日期（支付日期)分别为2016-01-01、2016-01-02和2016-01-02。(图11.10中数据不对)</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427123919363.png" alt="image-20210427123919363" loading="lazy"><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427123928446.png" alt="image-20210427123928446" loading="lazy"></p><h4 id="多事务事实表"><a href="#多事务事实表" class="headerlink" title="多事务事实表"></a>多事务事实表</h4><blockquote><p>将不同的事实放到同一个事实表中，即同一个事实表包含不同的业务过程。</p></blockquote><p>​    <strong>多事务事实表在设计时有两种方法进行事实的处理：</strong></p><ul><li>不同业务过程的事实使用不同的事实字段进行存放；</li><li>不同业务过程的事实使用同一个事实字段进行存放，但增加一个业务过程标签。</li></ul><p>​    下面以淘宝交易事务事实表和淘宝收藏商品事务事实表分别阐述其设计方法：</p><h5 id="淘宝交易事务事实表"><a href="#淘宝交易事务事实表" class="headerlink" title="淘宝交易事务事实表"></a>淘宝交易事务事实表</h5><blockquote><p>这里采用将不同业务过程的事实使用不同事实字段进行存放。</p></blockquote><ul><li>下单、支付和成功放到同一个事实表的原因：</li></ul><p>​    这三个业务过程都包含下单、支付和成功完结三个业务过程，都是子订单粒度，因此适合放到同一个事实表中。</p><ul><li>发货不放到同一个事实表的原因：</li></ul><p>​    发货的粒度比子订单更细，属于不同粒度上的业务过程。</p><p>​    在确定好业务过程和粒度后，下一步就是确定维度和事实。对于不同的业务过程和粒度，一般而言，维度也不完全一致。但是在设计淘宝交易事务事实表时，根据分析统计，常用维度比较一致，因此在维度层面可以保证这三个业务过程放到同一个事务事实表中。这里的维度也是在交易过程中比较常见的，如包括买家、卖家、商品、类目、店铺、收发货地区等，无论在哪一个业务过程中，都需要按照这些维度进行统计分析。</p><p>​    将多个业务过程放到同一个事实表中，将要面对的是如何处理多个事实。淘宝交易事务事实表中包含了下单、支付和成功完结三个业务过程，则<strong>需要包含下单度量、支付度量和成功完结度量信息</strong>，这里的解决方案是针对每个度量都使用一个字段进行保存，即不同的事实使用不同的字段进行存放；如果不是当前业务过程的度量，则采取零值处理方式。比如在下单业务过程中，对于支付度量和成功完结度量全部置为0，其他业务过程类似处理。</p><p>​    同一个事实表包含了多个业务过程，在表中如何进行标记？淘宝交易事务事实表<strong>针对每个业务过程打一个标签，标记当天是否是这个业务过程</strong>。比如针对下单，则打一个是否当天下单的标签；针对支付，则打一个是否当天支付的标签；针对完成，则打一个是否当天完成的标签，标签之间互不相干。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427150414607.png" alt="image-20210427150414607" loading="lazy"><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427150552763.png" alt="image-20210427150552763" loading="lazy"><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427150603996.png" alt="image-20210427150603996" loading="lazy"></p><h5 id="淘宝收藏商品事务事实表"><a href="#淘宝收藏商品事务事实表" class="headerlink" title="淘宝收藏商品事务事实表"></a>淘宝收藏商品事务事实表</h5><blockquote><p>这里采用在不同业务过程中使用同一个字段保存事实，使用标签字段区分不同的业务过程。比如：收藏事务事实表使用一个“收藏事件类型”字段来区分是收藏还是删除。</p></blockquote><p><strong>业务介绍：</strong>用户可以收藏一个商品，也可以删除所收藏的商品，所以这个过程包含了两个业务过程：收藏商品和删除商品。</p><p><strong>业务过程确定：</strong>收藏商品、删除商品</p><p><strong>粒度确定：</strong>无论是收藏还是删除，都是对商品进行操作，因此确定为用户-商品的粒度</p><p><strong>维度确定：</strong>由于粒度是用户商品粒度，所以主要维度就是用户维度和商品维度。为了使事实表信息更丰富，冗余了商品类目维度和商品所属卖家维度。收藏和删除业务过程所属的维度是一致的。</p><blockquote><p>虽然收藏和删除是两个不同的业务过程，但是有着相同的粒度和维度，所以考虑设计多事务事实表，将这两个业务过程放到同一个事实表中，只是在不同业务过程的事实上进行区分。</p></blockquote><p>​    收藏和删除的事实主要是商品价格，不过收藏事务事实表更多的是无事实的事实表，一般用于统计收藏或者删除的次数。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210427164833891.png" alt="image-20210427164833891" loading="lazy"></p><h5 id="多事务事实表的选择"><a href="#多事务事实表的选择" class="headerlink" title="多事务事实表的选择"></a>多事务事实表的选择</h5><ul><li>当不同业务过程的度量比较相似、差异不大时，可以采用第二种多事务事实表的设计方式，使用同一个字段来表示度量数据。但这种方式存在一个问题：在同一个周期内会存在多条记录。</li><li>当不同业务过程的度量差异较大时，可以选择第一种多事务事实表的设计方式，将不同业务过程的度量使用不同字段冗余到表中，非当前业务过程则置零表示。这种方式所存在的问题是度量字段零值较多。</li></ul><h4 id="两种事实表对比"><a href="#两种事实表对比" class="headerlink" title="两种事实表对比"></a>两种事实表对比</h4><h5 id="业务过程"><a href="#业务过程" class="headerlink" title="业务过程"></a>业务过程</h5><ul><li><strong>单事务事实表：</strong>一个业务过程建立一个事实表，只反映一个业务过程的事实；</li><li><strong>多事务事实表：</strong>在同一个事实表中反映多个业务过程。</li></ul><h5 id="粒度和维度"><a href="#粒度和维度" class="headerlink" title="粒度和维度"></a>粒度和维度</h5><ul><li><strong>单事务事实表：</strong>如果粒度不同，则必定是不同的事实表。</li><li><strong>多事务事实表：</strong>当不同业务过程的粒度相同时，且拥有相似的维度时，可以考研采用多事务事实表。</li></ul><h5 id="事实"><a href="#事实" class="headerlink" title="事实"></a>事实</h5><p>​    如果单一业务过程的事实较多，同时不同业务过程的事实又不相同，可以考虑使用单事务事实表，处理更加清晰。如果使用多事务事实表，则会导致事实表零值或空值字段较多</p><h5 id="下游业务使用"><a href="#下游业务使用" class="headerlink" title="下游业务使用"></a>下游业务使用</h5><p>​    单事务事实表对于下游用户而言更容易理解，关注哪个业务过程就使用相应的事务事实表；而多事务事实表包含多个业务过程，用户使用时会增加学习成本。</p><h5 id="计算存储成本"><a href="#计算存储成本" class="headerlink" title="计算存储成本"></a>计算存储成本</h5><p>​    当业务过程数据来源于同一个业务系统，具有相同的粒度和维度，不仅其加工计算成本较低，同时在存储上也相对节省，是一种较优的处理方式。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428125011024.png" alt="image-20210428125011024" loading="lazy"></p><h4 id="父子事实的处理方式"><a href="#父子事实的处理方式" class="headerlink" title="父子事实的处理方式"></a>父子事实的处理方式</h4><p>​    在同一个店铺同时下单多种商品，不仅每种商品有一个子订单，而且这几个子订单会再单独产生一个父订单。下单和支付都是在父订单粒度上完成的，比如拍下时的订单总额、支付总额、支付邮费，淘宝交易事务事实表在粒度选择上，按照粒度最细原则，确定为子订单，因此需要将下单总额或者支付总额分摊到每个子订单上，当然只有一个子订单时是不需要进行分摊的。下面以子订单分摊的有效下单金额和支付金额为例加以说明。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428125730010.png" alt="image-20210428125730010" loading="lazy"></p><p>​    通过分摊父订单的金额将所有业务过程的度量全部带进淘宝交易事务事实表中，包括下单数量、商品价格、子订单折扣、下单分摊比例、父订单支付金额、父订单支付邮费、父订单折扣、子订单下单金额、子订单下单有效金额、支付分摊比例、子订单支付金额等，将父子事实同时冗余到事务表中。</p><h4 id="事实的设计准则"><a href="#事实的设计准则" class="headerlink" title="事实的设计准则"></a>事实的设计准则</h4><h5 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h5><p>​    事实表包含与其描述的过程有关的所有事实，即<strong>尽可能多地获取所有的度量</strong>。</p><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>​    在确定事务事实表的事实时，明确存储每一个事实以确保度量的一致性。</p><p>​    以交易事务事实表为例，在下单业务过程中，有下单商品数量和商品价格两个事实，但在事实表中计算了下单金额和下单有效金额，它们可以通过商品数量乘以商品价格进行计算。虽然下游在取数时也可以通过这种方式完成计算，但是在事实表中统一计算可以保证度量的一致性，其他如支付过程中的分摊金额等也是类似的。</p><h5 id="可加性"><a href="#可加性" class="headerlink" title="可加性"></a>可加性</h5><p>​    <strong>事实表确定事实时，往往会遇到非可加性度量</strong>，比如分摊比例、利润率等，虽然它们也是下游分析的关键点，但<strong>往往在事务事实表中关注更多的是可加性事实</strong>，下游用户在聚合统计时更加方便。在淘宝交易事务事实表中，存储了分摊比例这样的度量，但更多的是存储各类金额的度量。</p><h3 id="周期快照事实表"><a href="#周期快照事实表" class="headerlink" title="周期快照事实表"></a>周期快照事实表</h3><blockquote><p>周期快照事实表以具有规律性的、可预见的时间间隔记录事实，如：日、周、月、年等。接下来以评价数据、卖家的累积支付金额、买卖家星级等事实表的设计为例展开介绍。</p></blockquote><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><blockquote><p>事务事实表的粒度能以多种方式表达，但快照事实表的粒度通常以维度形式声明；事务事实表是稀疏的，但快照事实表是稠密的；事务事实表中的事实是完全可加的，但快照模型将至少包含一个用来展示半可加性的事实。</p></blockquote><h5 id="用快照采样状态"><a href="#用快照采样状态" class="headerlink" title="用快照采样状态"></a>用快照采样状态</h5><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428143553428.png" alt="image-20210428143553428" loading="lazy"></p><h5 id="快照粒度"><a href="#快照粒度" class="headerlink" title="快照粒度"></a>快照粒度</h5><p>​    事务事实表的粒度可以通过业务过程中所涉及的细节程度来描述，但<strong>快照事实表的粒度通常总是被多维声明</strong>，可以简单地理解为<strong>快照需要采样的周期以及什么将被采样</strong>。在淘宝交易卖家快照事实表中，粒度可以被理解为每天针对卖家的历史截至当日的下单支付金额进行快照。<br>​    当然，快照周期不一定都按天来进行，也可以按照月或者季度来统计。比如淘宝交易有针对卖家加类目的每月汇总事实表，每月统计一次，同时维度也不仅一个，包含了卖家和类目。</p><h5 id="密度与稀疏性"><a href="#密度与稀疏性" class="headerlink" title="密度与稀疏性"></a>密度与稀疏性</h5><p>​    快照事实表和事务事实表的一个关键区别在密度上。事务事实表是稀疏的，只有当天发生的业务过程，事实表才会记录该业务过程的事实，如下单、支付等；而快照事实表是稠密的，无论当天是否有业务过程发生，都会记录一行，比如针对卖家的历史至今的下单和支付金额，无论当天卖家是否有下单支付事实，都会给该卖家记录一行。稠密性是快照事实表的重要特征，如果在每个快照周期内不记录行，比如和事务事实表一样，那么确定状态将变得非常困难。</p><h5 id="半可加性"><a href="#半可加性" class="headerlink" title="半可加性"></a>半可加性</h5><p>​    在快照事实表中收集到的状态度量都是半可加的。与事务事实表的可加性事实不同，半可加性事实不能根据时间维度获得有意义的汇总结果。比如对于淘宝交易事务事实表，可以对一个周期内的下单金额或者支付金额进行汇总，得到下单支付总额，但快照事实表在每个采样周期内是不能对状态度量进行汇总的。比如淘宝交易卖家快照事实表，无法对每天的历史至今的下单金额进行汇总，也没有汇总意义。虽然不能汇总，但可以计算一些平均值，比如计算每天一个下单的平均值。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote><p><strong>快照事实表的设计步骤：</strong></p><ul><li>确定快照事实表的快照粒度；</li><li>确定快照事实表采样的状态度量。</li></ul><p>下面介绍几类常见的快照事实表</p></blockquote><h5 id="单维度的每天快照事实表"><a href="#单维度的每天快照事实表" class="headerlink" title="单维度的每天快照事实表"></a>单维度的每天快照事实表</h5><ul><li><strong>确定粒度：</strong>采样<u>周期为每天</u>，针对卖家、买家、商品、类目、地区等维度的快照事实表，比如<u>淘宝卖家历史至今汇总事实表</u>、淘宝商品自然月至今汇总事实表等，<u>不同的采样粒度确定了不同的快照事实表</u>。</li><li><strong>确定状态度量：</strong><u>确定好粒度以后，就要针对这个粒度确定需要采样的状态度量。</u>比如<u>淘宝卖家历史至今汇总事实表</u>，<u>包含了历史截至当日的下单金额、历史截至当日的支付金额等度量</u>，如图11.17所示。<u>淘宝商品历史至今快照事实表，确定了商品维度和商品状态度量</u>，如图11.18所示。</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428144545680.png" alt="image-20210428144545680" loading="lazy"></p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428144610773.png" alt="image-20210428144610773" loading="lazy"></p><h5 id="混合维度的每天快照事实表"><a href="#混合维度的每天快照事实表" class="headerlink" title="混合维度的每天快照事实表"></a>混合维度的每天快照事实表</h5><p>​    混合维度相对于单维度，只是在每天的采样周期上<strong>针对多个维度进行采样</strong>。比如淘宝买卖家历史至今快照事实表，<u>采样周期依然是每天，维度是卖家加买家，反映的是不同买家对于不同卖家的下单支付金额</u>，如图11.19所示。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428144710825.png" alt="image-20210428144710825" loading="lazy"></p><p>​    以上两类快照事实表都有一个特点：都可以从事务事实表进行汇总产出，这是周期快照事实表常见的一种产出模式。</p><p>​    除此之外，还有一种产出模式，即直接使用操作型系统的数据作为周期快照事实表的数据源进行加工，比如淘宝卖家星级、卖家DSR事实表等。下面介绍这类事实表的设计过程。</p><p>​    <strong>卖家服务评价业务介绍：</strong>在店铺交易成功后，会进行一次好中差评价以及DSR评价（包括物流服务、描述相符和服务态度），卖家信用是基于好中差评计算得出的，DSR评分会累计计算一个综合分。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428145312341.png" alt="image-20210428145312341" loading="lazy"></p><p>​    其中卖家信用是通过好中差评的次数进行计算得到的，具体为：好评加一分、中评零分、差评扣一分，然后累积最终得分，得到卖家的信用。DSR评分是通过分项的星级综合得到最终的评分，其中描述相符、服务态度和物流服务都是1-5星的打分方式，综合每一个星级的买家数得到最终的一个平均分，具体为：（各星级评分人数*星级 求和）/（各星级人数之和）。</p><p>​    前面所述的卖家信用分和 DSR评分都是在操作型系统中计算完成的，阿里巴巴数据仓库关于淘宝卖家信用分和 DSR快照事实表是直接采用操作型系统数据进行设计加工，采样周期是每天，针对卖家维度的统计，状态度量就是卖家信用分和DSR评分，如图11.22所示。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428150212372.png" alt="image-20210428150212372" loading="lazy"></p><p><strong>总结：周期快照事实表常见的产出模式</strong></p><ul><li>从事务事实表进行汇总产出，如图11.18和图11.19</li><li>使用操作型系统的数据作为周期快照事实表的数据源进行加工</li></ul><h5 id="全量快照事实表"><a href="#全量快照事实表" class="headerlink" title="全量快照事实表"></a>全量快照事实表</h5><blockquote><p>下面以好中差评快照事实表为了展开叙述</p></blockquote><ul><li><p><strong>确定粒度：</strong>好中差评每天都会发生变化，下游分析统计也是每天都在进行的，因此确定采样周期是每天。这里的采用维度比较特殊，是针对评价本身，即每天按照评价进行采样的，每一条好中差评价就是快照事实表的最细粒度。</p></li><li><p><strong>确定状态度量：</strong>对于好中差评的度量关注更多的是评价本身，即没有类似于金额、商品数这样的度量，因此设计为无事实的事实表，更多关注评价的状态。</p><p>对于全量快照事实表，再增加一步，即冗余维度。比如好中差评快照事实表，冗余了子订单维度、商品维度、评价者维度、被评价者维度以及杂项维度，包括评价内容、是否匿名等信息，如11.23所示。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428151139249.png" alt="image-20210428151139249" loading="lazy"></p></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="事务与快照成对设计"><a href="#事务与快照成对设计" class="headerlink" title="事务与快照成对设计"></a>事务与快照成对设计</h5><p>​    数据仓库维度建模时，对于事务事实表和快照事实表往往都是成对设计的，互相补充，以满足更多的下游统计分析需求，特别是在事务事实表的基础上可以加工快照事实表，如前面所述的淘宝卖家历史至今快照事实表，就是在事务事实表的基础上加工得到的，既丰富了星形模型，又降低了下游分析的成本。</p><h5 id="附加事实"><a href="#附加事实" class="headerlink" title="附加事实"></a>附加事实</h5><p>​    快照事实表在确定状态度量时，一般都是保存采样周期结束时的状态度量。但是也有分析需求需要关注上一个采样周期结束时的状态度量，而又不愿意多次使用快照事实表，因此一般<strong>在设计周期快照事实表时会附加一些上一个采样周期的状态度量</strong>。</p><h5 id="周期到日期度量"><a href="#周期到日期度量" class="headerlink" title="周期到日期度量"></a>周期到日期度量</h5><p>​    在介绍淘宝卖家历史至今快照事实表时，指定了统计周期是卖家历史至今的一些状态度量，比如历史截至当日的下单金额、成交金额等。然而在实际应用中，也有需要关注自然年至今、季度至今、财年至今的一些状态度量，因此<strong>在确定周期快照事实表的度量时，也要考虑类似的度量值，以满足更多的统计分析需求</strong>。阿里巴巴数据仓库在设计周期快照事实表时，就<strong>针对多种周期到日期的度量设计了不同的快照事实表</strong>，比如淘宝卖家财年至今的下单金额、淘宝商品自然年至今的收藏次数等。</p><h3 id="累积快照事实表"><a href="#累积快照事实表" class="headerlink" title="累积快照事实表"></a>累积快照事实表</h3><blockquote><p>累积快照事实表用来表述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间点，当过程随着生命周期不断变化时，记录也会随着过程的变化而被修改。</p></blockquote><p>​    针对淘宝交易，设计了淘宝交易下单/支付/确认收货事务事实表，用于统计下单/支付/确认收货的子订单数、GMV（Gross Merchandise Volume 商品交易总额）等。但仍然有很多需求，此事务事实表很难满足，<strong>比如统计买家下单到支付的时长、买家支付到卖家发货的时长、买家从下单到确认收货的时长等</strong>。如果使用事务事实表进行统计，则逻辑复杂且性能很差。对于类似于研究事件之间时间间隔的需求，采用累积快照事实表可以很好地解决。</p><h4 id="设计过程-1"><a href="#设计过程-1" class="headerlink" title="设计过程"></a>设计过程</h4><blockquote><p>其建模过程和事务事实表相同，适用于维度建模的步骤。</p></blockquote><h5 id="第一步：选择业务过程"><a href="#第一步：选择业务过程" class="headerlink" title="第一步：选择业务过程"></a>第一步：选择业务过程</h5><p>​    针对淘宝交易累积快照事实表，选择买家下单、买家支付、卖家发货、买家确认收货这四个业务过程。</p><h5 id="第二步：确定粒度"><a href="#第二步：确定粒度" class="headerlink" title="第二步：确定粒度"></a>第二步：确定粒度</h5><p>​    选择子订单粒度。如果子订单同一周期发生多次事件，对于累计快照事实表，用于考察实体的唯一实例，所以子订单在此表中只有一行记录，事件发生时，对此实例进行更新。</p><h5 id="第二步：确定粒度-1"><a href="#第二步：确定粒度-1" class="headerlink" title="第二步：确定粒度"></a>第二步：确定粒度</h5><p>​    与事务事实表相同，维度主要有买家、卖家、店铺、商品、类目、发货地区、收获地区等。</p><p>​    四个业务过程对应的时间字段，格式为日期+时间，分别为下单时间、支付时间、发货时间、确认收货时间，对应于日期维表，图11.24中未标识。在实际使用时会使用视图或SQL别名的方式表示四个日期角色维度，类似于发货地区维度和收货地区维度。</p><p>​    在交易订单表中，存在很多与订单相关的属性，如订单类型、子类型、支付状态、物流状态、attributes、options等。对于类似的属性字段，无法归属到已有的商品等维度中，所以新建杂项维度存放。<strong>在数据仓库建模理论中，杂项维度无自然键，一般是枚举值的组合，对于每个组合生成一个代理键。但在实际建模中，存在很多非枚举值，且对于每个订单都不相同，如订单的attributes和 options属性。所以实际中杂项维度设计时，也可以直接使用自然键标识具体的维度值</strong>，如图11.24中所示的子订单维度和父订单维度。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428154831321.png" alt="image-20210428154831321" loading="lazy"></p><h5 id="第四步：确定事实-1"><a href="#第四步：确定事实-1" class="headerlink" title="第四步：确定事实"></a>第四步：确定事实</h5><p>​    <strong>对于累积快照事实表，需要将各业务过程对应的事实均放入事实表中。</strong>比如淘宝交易累积快照事实表，包含了各业务过程对应的事实，如下单对应的下单金额，支付对应的折扣、邮费和支付金额，确认收货对应的金额等。<strong>累积快照事实表解决的最重要的问题是统计不同业务过程之间的时间间隔，建议将每个过程的时间间隔作为事实放在事实表中。</strong>在淘宝交易累积快照事实表建模中，由于每个过程的时间间隔计算逻辑简单，因此并未加入事实表中，如图11.25所示。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428155128210.png" alt="image-20210428155128210" loading="lazy"></p><h5 id="第五步：退化维度"><a href="#第五步：退化维度" class="headerlink" title="第五步：退化维度"></a>第五步：退化维度</h5><p>​    在大数据的事实表模型设计中，更多的是考虑提高下游用户的使用效率，降低数据获取的复杂性，减少关联的表数量。一方面，存储成本降低了，而相比之下CPU成本仍然较高；另一方面，在大数据时代，很多维表比事实表还大，如淘宝几十亿的商品、几亿的买家等，在分布式数据仓库系统中，事实表和维表关联的成本很高。所以<strong>在传统的维度模型设计完成之后，在物理实现中将各维度的常用属性退化到事实表中，以大大提高对事实表的过滤查询、统计聚合等操作的效率</strong>，具体详情不再赘述。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><h5 id="数据不断更新"><a href="#数据不断更新" class="headerlink" title="数据不断更新"></a>数据不断更新</h5><p>​    事务事实表记录事务发生时的状态，对于实体的某一实例不再更新，而累计快照事实表则对实体的某一实例定期更新。下图11.3-11.5为多事务事实表的情况；11.6为累积快照事实表的情况，只有一条记录，针对此记录不断更新。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428155528820.png" alt="image-20210428155528820" loading="lazy"></p><h5 id="多业务过程日期"><a href="#多业务过程日期" class="headerlink" title="多业务过程日期"></a>多业务过程日期</h5><p>​    累积快照事实表适用于具有较明确起止时间的短生命周期的实体，比如交易订单、物流订单等，对于实体的每一个实例，都会经历从诞生到消亡等一系列步骤。<u>对于商品、用户等具有长生命周期的实体，一般采用周期快照事实表更合适。</u></p><p>​    <strong>累积快照事实表的典型特征是多业务过程日期，用于计算业务过程之间的时间间隔。</strong>但结合阿里巴巴数据仓库模型建设的经验，<strong>对于累积快照事实表，还有一个重要作用是保存全量数据。</strong></p><p>​    <strong>对于淘宝交易，需要保留历史截至当前的所有交易数据，其中一种方式是在ODS层保留和源系统结构完全相同的数据；但由于使用时需要关联维度，较为麻烦，所以在公共明细层需要保留一份全量数据，淘宝交易累积快照事实表就承担了这样的作用——存放加工后的事实，并将各维度常用属性和订单杂项维度退化到此表中</strong><u>（咱们的系统就是采用的第一种方式）</u>。通常用于数据探查、统计分析、数据挖掘等。</p><p><strong>总结：累积快照事实表的作用</strong></p><ul><li>多业务过程日期，用于计算业务过程之间的时间间隔</li><li>保存全量数据</li></ul><h4 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h4><h5 id="非线性过程"><a href="#非线性过程" class="headerlink" title="非线性过程"></a>非线性过程</h5><blockquote><p>买家申请退款→卖家不同意退款→买家申请退款→卖家不同意退款……一直到退款达成或关闭</p></blockquote><p>针对非线性过程，处理情况主要有以下几种。</p><p><strong>（1）业务过程的统一</strong><br>    比如流程结束标志的统一，最开始设计交易累积快照事实表时，以交易完成作为结束标志；进一步了解业务之后，发现交易关闭也是交易结束的一个分支，所以将交易结束作为流程结束、实体消亡的标志，包括交易完成和交易结束两种情况。</p><p><strong>（2）针对业务关键里程碑构建全面的流程</strong><br>    比如淘宝交易，全流程可能是下单→支付→发货→确认收货。对于没有支付或没有发货的交易订单，全流程仍然可以覆盖，相关业务过程的时间字段和事实置空。</p><p><strong>（3）循环流程的处理</strong><br>    主要问题是解决一个业务过程存在多个里程碑日期的问题。使用业务过程第一次发生的日期还是最后一次发生的日期，决定权在商业用户，而不是设计或开发人员。</p><h5 id="多源过程"><a href="#多源过程" class="headerlink" title="多源过程"></a>多源过程</h5><p>​    针对多业务过程建模时，业务过程可能来自于不同的系统或者来源于不同的表，其对于累积快照事实表的模型设计没有影响，但会影响ETL开发的复杂程度。对于淘宝交易累积快照事实表，除了上述提到的下单→支付→发货→确认收货流程，假设需要关注交易子订单退款业务或者物流业务，此时会涉及交易、售后、物流三个业务源系统。</p><p>​    退款业务流程如下:</p><p>​    下单→支付→买家申请退款→卖家同意退款→退款达成→交易关闭</p><p>​    或者</p><p>​    下单→支付→发货→买家申请退款→卖家同意退款→退款达成→交易关闭</p><p>​    或者</p><p>​    下单→支付→发货→买家申请退款→卖家不同意退款→退款取消→交易成功</p><p>​    针对多源业务建模，主要考虑事实表的粒度问题。对于淘宝交易累积快照事实表，其粒度是交易子订单。对于退款，由于每个子订单可能存在多次退款，此时如果要将退款相关业务过程加入模型中，则需要和商业用户确定存在多次退款时如何取舍，确保模型粒度不变。</p><h5 id="业务过程取舍"><a href="#业务过程取舍" class="headerlink" title="业务过程取舍"></a>业务过程取舍</h5><p>​    上一节提到的退款业务流程是简化的，比较完整的业务流程如下:</p><p>​    申请退款→申请小二介入→小二实际介入→卖家同意退款→退款完结</p><p>​    将退款相关业务流程设计进人交易累积快照事实表时，是否需要所有的业务过程？答案是否定的。当拥有大量的业务过程时，模型的实现复杂度会增加，特别是对于多源业务过程，模型的耦合度过高，此时需要根据商业用户需求，选取关键的里程碑。</p><h4 id="物理实现"><a href="#物理实现" class="headerlink" title="物理实现"></a>物理实现</h4><blockquote><p>针对累积快照事实表模型设计，有三种不同的实现方式。</p></blockquote><h5 id="全量表的形式"><a href="#全量表的形式" class="headerlink" title="全量表的形式"></a>全量表的形式</h5><p>​    此全量表一般为日期分区表，每天的分区存储昨天的全量数据和当天的增量数据合并的结果，保证每条记录的状态最新。</p><p>​    此种方式适用于全量数据较少的情况，如果数据量很大，此全量表数据量不断膨胀，存储了大量永远不再更新的历史数据，对ETL和分析统计性能影响较大。</p><h5 id="全量表的变化形式"><a href="#全量表的变化形式" class="headerlink" title="全量表的变化形式"></a>全量表的变化形式</h5><p>​    此种方式主要针对事实表数据量很大的情况。较短生命周期的业务实体一般从产生到消亡都有一定的时间间隔，可以测算此时间间隔，或者根据商业用户的需求确定一个相对较大的时间间隔。比如针对交易订单，我们以200天作为订单从产生到消亡的最大间隔。设计最近200天的交易订单累积快照事实表，每天的分区存储最近200天的交易订单；而200天之前的订单则按照gmt_create创建分区存储在归档表中。</p><p>​    此方式存在的一个问题是200天的全量表根据商业需求需要保留多天的分区数据，而由于数据量较大，存储消耗较大。</p><h5 id="以业务实体的结束时间分区"><a href="#以业务实体的结束时间分区" class="headerlink" title="以业务实体的结束时间分区"></a>以业务实体的结束时间分区</h5><p>​    每天的分区存放当天结束的数据，然后再设计一个时间非常大的分区，比如3000-12-31，存放截至当前未结束的数据。由于每天将当天结束的数据归档至当天分区中，时间非常大的分区数据量不会很大，ETL性能较好；并且无存储的浪费，对于业务实体的某具体实例，在该表的全量数据中唯一。比如对于交易订单，在交易累积快照事实表中唯一。</p><p>​    <strong>针对第三种方式，可能存在极特殊情况，即业务系统无法标识业务实体的结束时间。</strong>比如业务系统调用接口很多，依赖的系统复杂，最终无法判断业务实体是否已经消亡。如菜鸟的物流订单，由于其依赖物流公司的数据，和大量的物流公司存在接口，按照约定，物流公司会向菜鸟回传运单的流转信息，但无法保证100%准确；且一般为批量回传，菜鸟订单系统根据批量数据更新物流订单的结束标志几乎无法实现。前台业务系统没有物流订单的结束时间，那么如何设计物流订单累积快照事实表呢？针对此问题，可以有两种处理方式。</p><p>​    <strong>第一种方式，</strong>使用相关业务系统的业务实体的结束标志作为此业务系统的结束标志。比如针对物流订单，可以使用交易订单。理论上，交易订单完结了，则物流订单已经完结。</p><p>​    <strong>第二种方式，</strong>和前端业务系统确定口径或使用前端归档策略。累积快照事实表针对业务实体一般是具有较短生命周期的，和前端业务系统确定口径，确定从业务实体的产生到消亡的最大间隔。另外，针对大量的事实数据，前端系统会定期对历史数据进行归档，避免业务库性能的下降，对于这种情况，可以使用前端系统的归档时间作为业务实体的结束日期。</p><h3 id="三种事实表的比较"><a href="#三种事实表的比较" class="headerlink" title="三种事实表的比较"></a>三种事实表的比较</h3><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210428163153484.png" alt="image-20210428163153484" loading="lazy"></p><p>​    事务事实表记录的事务层面的事实，用于跟踪业务过程的行为，并支持几种描述行为的事实，保存的是最原子的数据，也称为“原子事实表”。事务事实表中的数据在事务事件发生后产生，数据的粒度通常是每个事务一条记录。一旦事务被提交，事实表数据被插入，数据就不能更改，其更新方式为增量更新。</p><p>​    周期快照事实表以具有规律性的、可预见的时间间隔来记录事实，如余额、库存、层级、温度等，时间间隔为每天、每月、每年等，典型的例子如库存日快照表等。周期快照事实表的日期维度通常记录时间段的终止日，记录的事实是这个时间段内一些聚集事实值或状态度量。事实表的数据一旦插入就不能更改，其更新方式为增量更新。</p><p>​    累积快照事实表被用来跟踪实体的一系列业务过程的进展情况，它通常具有多个日期字段，用于研究业务过程中的里程碑过程的时间间隔。另外，它还会有一个用于指示最后更新日期的附加日期字段。由于事实表中许多日期在首次加载时是不知道的，而且这类事实表在数据加载完成后，可以对其数据进行更新，来补充业务状态变更时的日期信息和事实。</p><h3 id="无事实的事实表"><a href="#无事实的事实表" class="headerlink" title="无事实的事实表"></a>无事实的事实表</h3><p>​    在维度模型中，事实表用事实来度量业务过程，不包含事实或度量的事实表称为“无事实的事实表”。虽然没有明确的事实，但可以用来支持业务过程的度量。</p><p>​    常见的无事实的事实表主要有如下两种:</p><ul><li><p>第一种是事件类的，记录事件的发生。在阿里巴巴数据仓库中，最常见的是日志类事实表。比如用户的浏览日志，某会员某时间点浏览了淘宝首页、某会员某时间点浏览了某卖家的店铺中的某商品详情页等。对于每次点击，其事实为1，但一般不会保存此事实。</p></li><li><p>第二种是条件、范围或资格类的，记录维度与维度多对多之间的关系。比如客户和销售人员的分配情况、产品的促销范围等。</p></li></ul><h3 id="聚集型事实表"><a href="#聚集型事实表" class="headerlink" title="聚集型事实表"></a>聚集型事实表</h3><p>​    阿里巴巴将使用频繁的公用数据，通过聚集进行沉淀，比如卖家最近1天的交易汇总表、卖家最近N天的交易汇总表、卖家自然年交易汇总表等。这类聚集汇总数据，被叫作“公共汇总层”。</p><p>​    在本节中，前半部分将会介绍聚集的基本原则和通用步骤，这些都是在建设聚集型事实表时必须明白的事情；后半部分将会介绍阿里巴巴建设公共汇总层的一些实践。</p><h4 id="聚集的基本原则"><a href="#聚集的基本原则" class="headerlink" title="聚集的基本原则"></a>聚集的基本原则</h4><ul><li><strong>一致性</strong></li></ul><blockquote><p><strong>聚集表必须提供与查询明细粒度数据一致的查询结果。从设计角度来看，确保一致性，最简单的方法是确保聚集星形模型中的维度和度量与原始模型中的维度和度量保持一致。</strong></p></blockquote><ul><li><strong>避免单一表设计</strong></li></ul><blockquote><p><strong>不要在同一个表中存储不同层次的聚集数据</strong>；否则将会导致双重计算或出现更糟糕的事情。在聚集表中有些行存放按天汇总的交易额，有些行存放按月汇总的交易额，这将会让使用者产生误用导致重复计算。为了避免此类问题，<strong>通用的做法是在聚集时显式地加入数据层级列以示区别，但是这样会加大使用者的使用成本。</strong>行之有效的<strong>另一种方法是把按天与按月汇总的交易额用两列存放，但是需要在列名或者列注释上能分辨出来</strong>。</p></blockquote><ul><li><strong>聚集粒度可不同</strong></li></ul><blockquote><p><strong>聚集并不需要保持与原始明细粒度数据一样的粒度，聚集只关心所需要查询的维度。</strong>订单涉及的维度有商品、买家、卖家、地域等，比如可以按照商品汇总一天的交易额，可以按照卖家汇总一天的营业额(交易额)，可以按照商品与地域汇总一月的交易额。</p></blockquote><h4 id="聚集的基本步骤"><a href="#聚集的基本步骤" class="headerlink" title="聚集的基本步骤"></a>聚集的基本步骤</h4><h5 id="第一步：确定聚集维度"><a href="#第一步：确定聚集维度" class="headerlink" title="第一步：确定聚集维度"></a>第一步：确定聚集维度</h5><p>​    在原始明细模型中会存在多个描述事实的维度，如日期、商品类别、卖家等，这时候需要确定根据什么维度聚集，如果只关心商品的交易额情况，那么就可以根据商品维度聚集数据。</p><h5 id="第二步：确定一致性上钻"><a href="#第二步：确定一致性上钻" class="headerlink" title="第二步：确定一致性上钻"></a>第二步：确定一致性上钻</h5><p>​    这时候要关心是按月汇总还是按天汇总，是按照商品汇总还是按照类目汇总，如果按照类目汇总，还需要关心是按照大类汇总还是小类汇总。当然，我们要做的只是了解用户需要什么，然后按照他们想要的进行聚集。</p><h5 id="第三步：确定聚集事实"><a href="#第三步：确定聚集事实" class="headerlink" title="第三步：确定聚集事实"></a>第三步：确定聚集事实</h5><p>​    在原始明细模型中可能会有多个事实的度量，比如在交易中有交易额、交易数量等，这时候要明确是按照交易额汇总还是按照成交数量汇总。</p><h4 id="公共汇总层"><a href="#公共汇总层" class="headerlink" title="公共汇总层"></a>公共汇总层</h4><h5 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h5><blockquote><p>除了聚集的基本原则外，阿里巴巴建设公共汇总层还必须遵循以下、原则。</p></blockquote><ul><li><p><strong>数据公用性:</strong></p><p>汇总的聚集会有第三者使用吗？基于某个维度的聚集是不是经常用于数据分析中？如果答案是肯定的，那么就有必要把明细数据经过汇总沉淀到聚集表中。</p></li><li><p><strong>不跨数据域：</strong></p><p>数据域是在较高层次上对数据进行分类聚集的抽象。阿里巴巴以业务过程进行分类，如交易统一划到交易域下，商品的新增、修改放到商品域下。</p></li><li><p><strong>区分统计周期：</strong></p><p>在表的命名上要能说明数据的统计周期，如_1d表示最近1天，_td表示截至当天，_nd表示最近N天。</p></li></ul><h5 id="交易汇总表设计"><a href="#交易汇总表设计" class="headerlink" title="交易汇总表设计"></a>交易汇总表设计</h5><p>​    聚集是指针对原始明细粒度的数据进行汇总。假定已有的交易订单明细模型如图11.26所示，可以看出事实和商品、卖家、买家等维度关联。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210429124126060.png" alt="image-20210429124126060" loading="lazy"></p><p>​    潜在的聚集如表11.8所示。</p><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210429124151375.png" alt="image-20210429124151375" loading="lazy"></p><p>​    可以看出聚集的组合可能性为各个维度属性个数的乘积:2×2×2×2×3×5…。下面将按照聚集的基本步骤来介绍聚集表的设计流程。</p><ul><li><p><strong>按照商品粒度汇总：</strong></p><ul><li>确定聚集维度：商品</li><li>确定一致性上钻：按商品（商品ID）最近一天汇总</li><li>确定聚集事实：下单量、交易额</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210429124358782.png" alt="image-20210429124358782" loading="lazy"></p><p>可以看出聚集的事实都是原始模型中的事实，聚集的维度也是原始模型维度中的商品维度，去掉了其他不关心的维度。</p></li><li><p><strong>按卖家粒度汇总：</strong></p><ul><li>确定聚集维度：卖家</li><li>确定一致性上钻：按卖家（卖家ID）最近七天和最近三十天汇总</li><li>确定聚集事实：交易额</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210429124547273.png" alt="image-20210429124547273" loading="lazy"></p><p>前面在“聚集的基本原则”中说过，应该避免将不同层级的数据放在一起，为此我们选择用两列存放7天和30天的事实，但是需要在列名和字段注释上说明清楚。</p></li><li><p><strong>按卖家、买家、商品粒度汇总：</strong></p><ul><li>确定聚集维度：卖家、买家、商品</li><li>确定一致性上钻：按卖家（卖家ID）、买家（买家ID）、商品（商品ID）最近一天汇总</li><li>确定聚集事实：交易额</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210429124923879.png" alt="image-20210429124923879" loading="lazy"></p><p>可以看出聚集的粒度越细，记录的条数越多，就会越接近原始明细模型的粒度。</p></li><li><p>按二级类目汇总：</p><ul><li>确定聚集维度：二级类目</li><li>确定一致性上钻：按最近1天类目维度的二级维度属性汇总</li><li>确定聚集事实：交易额</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-03/image-20210429125116834.png" alt="image-20210429125116834" loading="lazy"></p><p>与之前的三个聚集表不同的是，这个聚集模型不是根据维度主键属性进行的聚集，而是根据类目的层次维度属性进行的上钻聚集。</p></li></ul><h4 id="聚集补充说明"><a href="#聚集补充说明" class="headerlink" title="聚集补充说明"></a>聚集补充说明</h4><h5 id="聚集是不跨越事实的"><a href="#聚集是不跨越事实的" class="headerlink" title="聚集是不跨越事实的"></a>聚集是不跨越事实的</h5><p>​    聚集是针对原始星形模型进行的汇总,为了获取和查询与原始模型一致的结果，聚集的维度和度量必须与原始模型保持一致，因此聚集是不跨越事实的。横向钻取是针对多个事实基于一致性维度进行的分析，很多时候采用融合事实表,预先存放横向钻取的结果，从而提高查询性能。因此，融合事实表是一种导出模式而不是聚集。</p><h5 id="聚集带来的问题"><a href="#聚集带来的问题" class="headerlink" title="聚集带来的问题"></a>聚集带来的问题</h5><p>​    聚集会带来查询性能的提升，但聚集也会增加ETL维护的难度。当子类目对应的一级类目发生变更时，先前存在的、已经被汇总到聚集表中的数据需要被重新调整。这一额外工作随着业务复杂性的增加，会导致多数ETL人员选择简单强力的方法，删除并重新聚集数据。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事实表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维度表设计</title>
      <link href="2021/08/05/dw-dimensional-modeling-02/"/>
      <url>2021/08/05/dw-dimensional-modeling-02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="维度设计基础"><a href="#维度设计基础" class="headerlink" title="维度设计基础"></a>维度设计基础</h3><h4 id="维度的基本概念"><a href="#维度的基本概念" class="headerlink" title="维度的基本概念"></a>维度的基本概念</h4><p>维度所包含的表示维度的列，称为维度属性。维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。维度的作用一般是查询约束、分类汇总以及排序等。</p><a id="more"></a><h4 id="维度的获取"><a href="#维度的获取" class="headerlink" title="维度的获取"></a>维度的获取</h4><ul><li>在报表中获取；</li><li>与业务人员沟通发现维度，因为他们经常出现在查询或报表请求中的 <code>by</code> 语句内。</li></ul><h4 id="维度的唯一性"><a href="#维度的唯一性" class="headerlink" title="维度的唯一性"></a>维度的唯一性</h4><p>维度使用主键标识其唯一性，主键有两种：</p><ul><li>代理键：就是充当主键的字段本身不具有业务意义，只具有主键作用，比如自动增长的ID。代理键一般用于处理缓慢变化维。</li><li>自然键：就是充当主键的字段本身具有一定的含义，是构成记录的组成部分，比如商品的条码，除了充当主键之外，同时也是商品记录的重要组成部分。</li></ul><h4 id="维度的设计方法"><a href="#维度的设计方法" class="headerlink" title="维度的设计方法"></a>维度的设计方法</h4><p>数据仓库的能力直接与维度属性的质量和深度成正比。下面以商品维度为例，对维度设计方法进行详细说明。</p><ul><li><strong>第一步：选择维度或新建维度。</strong>在数仓中，必须保证维度的唯一性。以商品维度为例，有且只允许有一个维度定义。</li><li><strong>第二步：确定主维表。</strong>此处的主维表一般是ODS表，直接与业务系统同步。以商品维度为例，ods.ods_lx_pub_goodsinfo是与业务库pub_goodsinfo直接同步的商品表，此表即为主维表。</li><li><strong>第三步：确定相关维表。</strong>数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。根据对业务的梳理，确定哪些表和主维表存在关联，并选择其中的某些表用于生成维度属性。以pub_goodsinfo为例，根据对业务逻辑的梳理，可以得到商品与商品分类、店铺、大小包装绑定、供应商等维度存在关联关系。</li><li><strong>第四步：确定维度属性。</strong>包括两个阶段：<strong>第一阶段是从主维度表</strong>中选择维度属性或生成新的维度属性；<strong>第二阶段是从相关维表</strong>中选择维度属性或生成新的维度属性。以商品维度为例，从pub_goodsinfo和商品分类、大小包装绑定等相关维表中选择维度属性或生成新的维度属性。</li></ul><blockquote><p>确定维度属性的几点提示：</p></blockquote><ul><li><strong>尽可能生成丰富的维度属性</strong>，为下游的数据统计、分析提供良好的基础；</li><li><strong>尽可能多地给出包括一些富有意义的文字性描述</strong>；属性不应该是编码，而应该是真正的文字，比如商品的gods_id和gods_name。id一般用于关联，而名称一般用于报表标签。</li><li><strong>区分数值型属性和事实</strong>：如果用于查询约束条件或分组统计，则作为维度属性；如果用于度量的计算，则作为事实。不过，这并不绝对，需要同时参考字段的具体用途。</li><li><strong>尽量沉淀出通用的维度属性</strong>。<strong>有些维度属性获取需要进行比较复杂的逻辑处理</strong>，有些需要通过多表关联得到，或者通过单表的不同字段混合处理得到，或者通过对单表的某个字段进行解析得到。此时，需要将尽可能多的通用的维度属性进行沉淀。<u>一方面，可以提高下游使用的方便性，减少复杂度；另一方面，可以避免下游使用解析时由于各自逻辑不同而导致口径不一致。</u>例如，商品是否在线，是重要的查询约束的条件，但是无法直接获取，需要进行加工，所以需要封装商品是否在线的逻辑作为一个单独的属性字段。</li></ul><h4 id="维度的层次结构"><a href="#维度的层次结构" class="headerlink" title="维度的层次结构"></a>维度的层次结构</h4><p>维度中的一些 描述属性 以 层次方式或一对多的方式 相互关联，可以被理解为包含连续主从关系的属性层次。最底层代表详细信息，最高层代表概要信息。例如商品维度，有店铺、商品类别、品牌等。商品属于类别，类别属于行业，其中类别的最低级别是叶子类别，叶子类别属于二级类别，二级类别属于一级类别。</p><p><strong>店铺、商品类别、品牌等属性层次是实例化为多个维度，还是作为维度属性保存在商品维度中？</strong></p><h4 id="规范化和反规范化"><a href="#规范化和反规范化" class="headerlink" title="规范化和反规范化"></a>规范化和反规范化</h4><p>首先介绍下规范化与反规范化的理论</p><ul><li>规范化：常见的规范化有数据库设计的三范式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1NF 是最低的规范化要求。如果关系 R 中所有属性的值域都是简单域，属性不可再分。</span><br><span class="line">2NF 非主属性完全函数依赖于码</span><br><span class="line">3NF 非主属性不传递依赖于任何一个候选码</span><br></pre></td></tr></table></figure><ul><li>反规范化：对完全规范的数据库查询，通常需要更多的连接操作，从而影响查询速度。因此，有时为了提高某些查询或应用的性能而破坏规范规则，即反规范化。常见的反规范化技术包括：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（1）增加冗余列</span><br><span class="line">增加冗余列是指在多个表中具有相同的列，它常用来在查询时避免连接操作。例如：以规范化设计的理念，学生成绩表中不需要字段“姓名”，因为“姓名”字段可以通过学号查询到，但在反规范化设计中，会将“姓名”字段加入表中。这样查询一个学生的成绩时，不需要与学生表进行连接操作，便可得到对应的“姓名”。</span><br><span class="line"></span><br><span class="line">（2）增加派生列</span><br><span class="line">增加派生列指增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。例如：订单表中，有商品号、商品单价、采购数量，我们需要订单总价时，可以通过计算得到总价，所以规范化设计的理念是无须在订单表中设计“订单总价”字段。但反规范化则不这样考虑，由于订单总价在每次查询都需要计算，这样会占用系统大量资源，所以在此表中增加派生列“订单总价”以提高查询效率。</span><br><span class="line"></span><br><span class="line">（3）重新组表</span><br><span class="line">重新组表指如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。</span><br><span class="line"></span><br><span class="line">（4）分割表</span><br><span class="line">有时对表做分割可以提高性能。表分割有两种方式。</span><br><span class="line">水平分割：根据一列或多列数据的值把数据行放到两个独立的表中。水平分割通常在下面的情况下使用。</span><br><span class="line"></span><br><span class="line">情况 1：表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询效率。</span><br><span class="line">情况 2：表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</span><br><span class="line">情况 3：需要把数据存放到多个介质上。</span><br><span class="line"></span><br><span class="line">（5）垂直分割：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割，另外垂直分割可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少 I&#x2F;O 次数。其缺点是需要管理冗余列，查询所有数据需要连接操作。</span><br></pre></td></tr></table></figure><p>下面进行案例介绍：</p><p>当属性层次被实例化为一系列维度，而不是单一的维度属性时，被称为<strong>雪花模式</strong>。大多数联机事务处理系统（OLTP）的底层数据结构在设计时采用此种<strong>规范化</strong>技术，通过规范化处理将重复属性移至其自身所属的表中，删除冗余数据。下图是规范化的商品维度所表现的形式：</p><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210729102521173.png" alt="image-20210729102521173" loading="lazy"></p><p>将维度的属性层次合并到单个维度中的操作称为<strong>反规范化</strong>，采用反规范化处理后的数据表，使用起来更方便、易用且性能好。下图是反规范化后的商品维度的表现形式：</p><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210729102748467.png" alt="image-20210729102748467" loading="lazy"></p><p>在OLAP系统中，几乎总是使用维表的空间来换取易用性（即采用第二种方式）。</p><h4 id="一致性维度和交叉探查"><a href="#一致性维度和交叉探查" class="headerlink" title="一致性维度和交叉探查"></a>一致性维度和交叉探查</h4><p>假设对于日志数据域，统计了商品维度的最近一天的PV和UV；对于交易数据域，统计了商品维度的最近一天的下单GMV。现在准备将不同数据域的商品的事实表合并在一起进行分析，如计算转化率，称为交叉探查。如果不同数据域的计算过程使用的维度不一致，就会导致交叉探查存在问题。</p><blockquote><p>维度一致性的几种表现形式</p></blockquote><ul><li><strong>共享维表。</strong>如：商品维度有且只有一个</li><li><strong>一致性上卷，其中一个维度的维度属性是另一个维度的维度属性的子集，且两个维度的公共维度属性结构和内容相同。</strong>例如商品维度和类别维度，其中类别维度的维度属性是商品维度的维度属性的子集，且有相同的维度属性和维度属性值。</li><li><strong>交叉属性，两个维度具有部分相同的维度属性。</strong>如在商品维度中具有类别属性，在店铺维度中有主营类别属性，两个维度存在相同的维度属性——类别属性，则可以在类别属性上进行不同业务过程的交叉探查。</li></ul><h3 id="维度设计高级主题"><a href="#维度设计高级主题" class="headerlink" title="维度设计高级主题"></a>维度设计高级主题</h3><h4 id="维度整合"><a href="#维度整合" class="headerlink" title="维度整合"></a>维度整合</h4><blockquote><p>数据仓库的定义：数据仓库是一个面向主题的、<strong>集成的</strong>、非易失的、随时间变化的数据集合。</p></blockquote><p>集成表现在如下几个方面：</p><ul><li>命名规范的统一：字段名、表名等的统一</li><li>字段类型的统一：相同或相似字段的字段类型统一</li><li>公共代码和代码值的统一：公共代码及标志性字段的数据类型、命名方式等的统一</li><li>业务含义相同的表的统一：主要依据高内聚、低耦合的理念，在物理实现中，将业务关系大、源系统影响差异小的表进行整；将业务关系小、源系统影响差异大的表进行分而置之。</li></ul><p>通常有如下几种集成方式：</p><ul><li><p>采用主从表的设计方式：将两个表或多个表都有的字段放在主表中（主要基本信息），从属信息分别放在各自的从表中。对于主表中的主键,要么采用复合主键、源主键和系统或表区别标志；要么采用唯一主键、“源主键和系统或表区别标志”生成新的主键。通常建议采用复合主键的方式。</p></li><li><p>直接合并</p></li><li><p>不合并，使用数据仓库中的多个表存放各自的数据。</p></li></ul><blockquote><p>维表的整合涉及的类容与上面介绍的几个方面相同，下面重点介绍表级别的整合，有两种表现形式：</p></blockquote><ul><li><strong>垂直整合：</strong>例如商品在业务系统中有多个表，商品档案、商品单位、商品分类等，这些表都属于商品相关信息表，依据维度设计方法，尽量整合至商品维度中，丰富其维度属性。</li><li><strong>水平整合：</strong>例如业务系统中有商品档案，也有商城商品档案，两者之间可能存在交叉。是否需要将这两个表水平整合到同一个商品表呢？如果进行整合的话，需要考虑两种商品体系之间是否有交叉，如果存在交叉，则需要进行去重；如果不存在交叉，需要考虑两个商品体系的自然键是否存在冲突，如果不存在冲突，则可以考虑将各子集的自然键作为整合后的表的自然键；另一种方式是设置超自然键，将两个体系的自然键加工成一个字段作为超自然键。</li></ul><p><em>水平整合就是把几个不相干，只是有关系，甚至没有关系的几个组织，通常是主企业把他们合并到一个较大企业内。这几个企业可以是互相竞争，也可以是互相协调，也可以是完全没有关系的。 比如：你现在的企业是个纺织厂，现在把食品厂、五金厂、汽车厂、维修厂或者加工厂合并到你现在的企业，这样的想法或者发展方向，就叫做——水平整合战略、横向整合战略。</em><br><em>如果是与现在的企业是直接竞争的企业，或者上下游企业，或者是互帮互助企业，那么就叫做——垂直整合战略、纵向整合战略。 如：你现在是纺织厂，把纺纱厂等合并到你现在的企业的这种发展方向，那就是——垂直整合战略。</em></p><p><strong>有整合就有拆分，到底是整合还是拆分，由多种因素决定。</strong></p><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><ul><li>将维度的不同分类实例化为不同的维度，同时在主维度中保存公共属性</li><li>维护单一维度，包含所有可能的属性。</li></ul><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>出于扩展性、产出时间、易用性等方面的考虑，设计主从维度。<strong>主维表</strong>存放稳定、产出时间早、热度高的属性；<strong>从维表</strong>存放变化较快、产出时间晚、热度低的属性。</p><h4 id="历史归档"><a href="#历史归档" class="headerlink" title="历史归档"></a>历史归档</h4><h3 id="维度变化"><a href="#维度变化" class="headerlink" title="维度变化"></a>维度变化</h3><h4 id="缓慢变化维"><a href="#缓慢变化维" class="headerlink" title="缓慢变化维"></a>缓慢变化维</h4><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210729135304789.png" alt="image-20210729135304789" loading="lazy"></p><p>有三种处理缓慢变化维的方式：</p><ul><li><strong>重写维度值：</strong>即不保留历史数    据，始终取最新数据；</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210729135313551.png" alt="image-20210729135313551" loading="lazy"></p><ul><li><strong>插入新的维度行：</strong>保留历史数据，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联。</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210729135325187.png" alt="image-20210729135325187" loading="lazy"></p><ul><li><strong>添加维度列：</strong>保留历史数据，对于需要分析历史信息的属性添加一列，来记录该属性变化前的值，而本属性字段使用TYPE 1来直接覆盖。</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210729135927920.png" alt="image-20210729135927920" loading="lazy"></p><h4 id="快照维表"><a href="#快照维表" class="headerlink" title="快照维表"></a>快照维表</h4><p>用于解决<strong>不使用代理键来解决缓慢变化维</strong>的问题。</p><p>在阿里巴巴数据仓库实践中，处理缓慢变化维的方法是采用快照方式。数据仓库的计算周期一般是每天一次，基于此周期，处理维度变化的方式就是每天保留一份全量快照数据。此方法既有优点，也有弊端。缺点很明显：极大占用了存储空间。</p><h4 id="极限存储"><a href="#极限存储" class="headerlink" title="极限存储"></a>极限存储</h4><p><strong>按日做拉链表</strong>，用于解决缓慢变化维的第二种处理方式。通过新增两个时间戳字段，将所有以天为粒度的变更数据都记录下来。这种处理方式用start_dt和end_dt作为分区，随着时间推移，分区数量会极度膨胀，并且拉链表在供前端使用时还需要进行解释拉链表怎么用，存在解释成本。为了解决这两个问题，采用以下方式：</p><ul><li><p><strong>按月做拉链表</strong></p></li><li><p><strong>透明化：</strong>底层还是拉链表，但是上层做一个视图操作或者在hive里做一个hook，通过分析语句的语法树，把对拉链表转换为一个正常的表用于查询，即通过转换达到以下两个查询结果一样的效果。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> ds = <span class="number">20210101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A_exst <span class="keyword">where</span> start_dt&lt;=<span class="number">20210101</span> <span class="keyword">and</span> end_dt&gt;<span class="number">20210101</span>;</span><br></pre></td></tr></table></figure><h4 id="微型维度"><a href="#微型维度" class="headerlink" title="微型维度"></a>微型维度</h4><blockquote><p>微型维度的提出主要是为了解决快变超大维度</p></blockquote><p>将分析频率比较高或者变化频率比较大的字段提取出来，建立一个单独的维度表。这个单独的维度表就是微型维度表。</p><p>微型维度表有自己的关键字（使用代理键），这个关键字和原维度表的关键字一起进入事实表。有时为了分析的方便，可以把微型维度的关键字的最新值作为外关键字进入客户维度表。这时一定要注意，这个外关键字必须做<em>TYPE 1型处理。</em></p><p>微型维度有如下缺点，因此在阿里的数仓实践中，并未采用此技术：</p><ul><li>微型维度的局限性。微型维度是事先用所有可能值的组合加载的，需要考虑每个属性的基数，且必须是枚举值。很多属性可能是非枚举型，比如数值类型，如 VIP分数、信用分数等;时间类型，如上架时间、下架时间、变更时间等。</li><li>ETL逻辑复杂。对于分布式系统,生成代理键和使用代理键进行ETL加工都非常复杂，ETL开发和维护成本过高。</li><li>破坏了维度的可浏览性。买家维度和微型维度通过事实表建立联系,无法基于VIP等级、信用等级进行浏览和统计。可以通过在买家维度中添加引用微型维度的外键部分来解决此问题,但带来的问题是微型维度未维护历史信息。</li></ul><h3 id="特殊维度"><a href="#特殊维度" class="headerlink" title="特殊维度"></a>特殊维度</h3><h4 id="递归层次"><a href="#递归层次" class="headerlink" title="递归层次"></a>递归层次</h4><ul><li>均衡层次结构</li><li>非均衡层次结构</li></ul><p>递归层次可以通过递归sql来探查，但是很多数仓系统不支持递归sql，且使用成本较高，因此在维度模型中，需要对此类层次结构进行处理。</p><ul><li><strong>层次结构扁平化：</strong>可以一定程度上解决上钻和下钻问题，如下图所示的类别扁平化后</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730161256971.png" alt="image-20210730161256971" loading="lazy"></p><p>但是存在如下三个问题：</p><ol><li>针对某个类目进行上钻或下钻之前，必须知道其所属的类目层级，然后才能决定限制哪一级类目。</li><li>当统计三级类目的数据时，由于某些叶子类目是一级类目或二级类目，如类目ID为121456022的类目，和事实表关联后，其对应的三级类目为空，导致根据三级类目统计时，类目ID为121456022的交易无法被统计。</li><li>扩展性较差。</li></ol><p>对于第二个问题，采取回填的方式来解决：</p><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730162127288.png" alt="image-20210730162127288" loading="lazy"></p><ul><li><strong>层次桥接表：</strong>灵活性好，但是更复杂，使用成本高。</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730162330445.png" alt="image-20210730162330445" loading="lazy"></p><h4 id="行为维度"><a href="#行为维度" class="headerlink" title="行为维度"></a>行为维度</h4><blockquote><p>和事实相关的维度，如交易、物流等维度，称为行为维度，或事实衍生的维度</p></blockquote><p><strong>按照加工方式，行为维度可划分为：</strong></p><ul><li>过去行为，如买家最近一次访问淘宝时间，最后一次交易时间。</li><li>快照事实行为维度，如买家至今的交易金额，信用分值。</li><li>分组事实行为维度，就是将上面的数值型数据转换为枚举型，例如将信用分转为信用等级。</li><li>复杂逻辑事实行为维度，通过复杂加工得到。</li></ul><p><strong>对于行为维度，有两种处理方式：</strong></p><ul><li>可以将维度冗余至现有的维度表中，比如将买家信用等级冗余至买家维度表。</li><li>也可以加工成单独的行为维度，如：卖家主营类目维度。</li></ul><p><strong>具体采用哪种方式，有如下两个参考原则：</strong></p><ul><li>避免维度过快增长：比如对商品表进行了极限存储，如果将商品热度加入现有的商品维表中，则可能会使每日商品变更占比过高，从而导致极限存储效果较差。</li><li>避免维度过快增长：比如卖家主营类目，加工逻辑异常复杂，如果融合进现有的卖家维表中，那么过多的业务耦合会导致卖家维表刷新逻辑复杂、维护性差、产出延迟等。</li></ul><h4 id="多值维度"><a href="#多值维度" class="headerlink" title="多值维度"></a>多值维度</h4><p>事实表中的一行对应维度表中多行的情况，产生多值维度。针对多值维度，有三种常见的处理方式：</p><ul><li>降低事实表的粒度：如将交易订单设计为子订单粒度，对于每个交易订单，只有一个商品与之对应，对于其中的事实，则采用分摊的方式。</li><li>使用多字段：在事实表中增加多个字段来标记同一个订单的同种维度值</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730164139062.png" alt="image-20210730164139062" loading="lazy"></p><ul><li>使用较为通用的桥接表：通过在事实表和维表之间开发一个分组表，通过此分组表建立连接。模型设计如图10.8所示，其中桥接表包含和事实表关联的分组KEY，以及作为买受方维表外键的买受方ID。如果事实表的一条记录对应两个买受方，则桥接表针对这两个买受方建立两条记录，分组KEY相同。</li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730164305055.png" alt="image-20210730164305055" loading="lazy"></p><h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><p>维表中的某个属性字段同时有多个值，这种情况称之为“多值属性”。是<code>多值维度</code>的另一种表现形式。</p><p>对于多值属性，有三种常见处理方式：</p><ul><li>保持维度主键不变，将多值属性放在维度的一个属性字段中。如通过k-v的形式：<code>12:2212; 13:13144; 14:12444</code></li><li>保持维度主键不变，将多值属性放在维度的多个属性字段中。<strong>扩展性较差</strong></li></ul><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730164845275.png" alt="image-20210730164845275" loading="lazy"></p><ul><li>维度主键发生变化，一个维度值存放多条记录。比如商品的sku维表，对于每个商品有多少sku,就有多少条记录，主键是商品ID 和SKU的 ID。<strong>扩展性好，使用方便。</strong></li></ul><h4 id="杂项维度"><a href="#杂项维度" class="headerlink" title="杂项维度"></a>杂项维度</h4><p>杂项维度是由操作系统中的指示符或者标志字段组合而成，一般不在一致性维度之列。</p><p>在实际操作中，会使用实体的自然主键作为杂项维度的主键，如：</p><p><img src="/2021/08/05/dw-dimensional-modeling-02/image-20210730170105239.png" alt="image-20210730170105239" loading="lazy"></p><p>但是子订单杂项维度一般是逻辑模型，不进行物理化实现，订单杂项维度和其他维度一起，会将维度属性退化至事实表中，详情在事实表中描述。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 维度表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维度建模的整体过程</title>
      <link href="2021/08/05/dw-dimensional-modeling-01/"/>
      <url>2021/08/05/dw-dimensional-modeling-01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>维度建模<strong>从分析决策的需求</strong>出发构建模型，为分析需求服务。代表的是<strong>星形模型</strong>，以及在一些特殊场景下使用的<strong>雪花模型</strong>。</p></blockquote><a id="more"></a><h4 id="维度建模的过程："><a href="#维度建模的过程：" class="headerlink" title="维度建模的过程："></a>维度建模的过程：</h4><ul><li><strong>选择</strong>需要进行分析决策的<strong>业务过程</strong>：业务过程可以是<strong>单个业务事件</strong>，也可以是<strong>某个事件的状态</strong>，也可以是<strong>一系列相关业务事件组成的业务流程</strong>。例如：交易的支付和退款、当前商品的库存量等。</li><li><strong>选择粒度</strong>：粒度是维度的一个组合。</li><li><strong>识别维度：</strong>选择好粒度之后，就需要基于此粒度设计为维表，包括维度属性，用于分析时进行分组和筛选。</li><li><strong>选择事实</strong>：确定分析需要衡量的指标。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 维度建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>record</title>
      <link href="2021/08/05/record/"/>
      <url>2021/08/05/record/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>20210805 操作记录</p></blockquote><ul><li>针对所有文章进行重新归档</li></ul><ul><li>对于文章图片缺失的部分进行补充</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
